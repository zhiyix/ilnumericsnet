<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics.Drawing</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.Drawing.ILRenderProperties">
            <summary>
            extended drawing properties
            </summary>
            <remarks>the class collects flags for special
            rendering states (vector exports, picking).
            </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Camera">
            <summary>
            current camera 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Clipping">
            <summary>
            current clipping (view limits) data
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Graphics">
            <summary>
            if not null, the rendering should be done offscreen via this graphics object
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Canceled">
            <summary>
            if set to true while rendering, the render process will be cancelled 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Reason">
            <summary>
            inform content object of the reason for rendering, see the <see cref="T:ILNumerics.Drawing.RenderReason">enumeration</see> for possible values.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MinX">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MaxValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MaxX">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MinValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MinY">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MaxValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MaxY">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MinValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.PassCount">
            <summary>
            Some rendering settings require multiple rendering passes. Those are counted here.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderProperties.Reset">
            <summary>
            Resets this instance.
            </summary>
            <returns>Instance reset to default values.</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureStorage">
            <summary>
            The class provides texture storage for a single class of texures (f.e. one font)
            </summary>
            <remarks>The texture items are stored in a single texture sheet 
            and organized via a simple binary tree.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILTextureStorage.m_disposed">
            <summary>
             cache, which texture has been bound at last
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.#ctor(System.Int32,System.Int32)">
            <summary>
            construct new storage
            </summary>
            <param name="height">absolute height (permanent)</param>
            <param name="width">absolute width (permanent)</param>
            <remarks>Suggested size parameter will be increased to the next power of two.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Get(System.String)">
            <summary>
            fetch texture item from storage
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.TryGetTextureItem(System.String,ILNumerics.Drawing.Labeling.ILTextureData@)">
            <summary>
            try to fetch item by key
            </summary>
            <param name="key">unique key</param>
            <param name="item">[output] item found</param>
            <returns>true: item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Exists(System.String)">
            <summary>
            test, if a key exists in the texture storage
            </summary>
            <param name="key">unique key to be tested for</param>
            <returns>true if a texture item associated with that key exists, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.String,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            store bitmap into texture sheet
            </summary>
            <param name="key">unique key for item</param>
            <param name="data">item bitmap data</param>
            <param name="rect">rectangle used in data bitmap</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            store bitmap into texture sheet
            </summary>
            <param name="key">unique key for item</param>
            <param name="data">item bitmap data</param>
            <param name="bmpRect">used rectangle in data bitmap</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="data">new item bitmap data</param>
            <param name="location">area in bitmap data to be stored</param>
            <param name="rect">rectangle specifying area to store the data into,
            texture coords: range from 0...1.0</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.MakeCurrent">
            <summary>
            select the texture storage as current in the GL
            </summary>
            <remarks>Calling this function before an storage / render operation is 
            obligatory in specific rendering machines (f.e. OpenGL). For GL's, where 
            it is not neccessary, the implementation must ignore any calls to this function.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Dispose">
            <summary>
            Dispose off any texture storage's ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Dispose(System.Boolean)">
            <summary>
            Dispose off manually
            </summary>
            <param name="manual"></param>
            <remarks>The true disposing is done in the concrete implementation.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Finalize">
            <summary>
            Finalizer, disposing ressources
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.Height">
            <summary>
            overall height of the internal texture sheet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.Width">
            <summary>
            current width of the internal texture sheet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.TextureID">
            <summary>
            Key used to identify the texure in the graphic system 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureStorage.Node">
            <summary>
            class representing a binary tree, used to manage the items on the texture sheet
            </summary>
            <remarks>This code is a slightly modified version of the OpenTK.Utilities framework
            TextPrinter/TextureStorage classes. See http://opentk.com for details.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILVectorField2D">
            <summary>
            visualizes 2D vector fields
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILPlot">
            <summary>
            (abstract) base class for all higher level plot objects
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode">
            <summary>
            scene graph inner node, collection of children
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphNode">
            <summary>
            abstract base class for all scene graph nodes
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.EventingSuspend">
            <summary>
            stop firing events from this node
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.EventingResume">
            <summary>
            resume firing events from this node
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Invalidate">
            <summary>
            invalidate geometry cache for this and all nodes up to root
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw all children contained in this node
            </summary>
            <param name="props">extended rendering properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.GetEnumerator">
            <summary>
            Create &amp; returns a typed enumerator
            </summary>
            <returns>enumerator of all scene graph nodes below this node</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Create and return untyped enumerator
            </summary>
            <returns>IEnumerator of all scene graph nodes below this node</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraphNode.SizeChanged">
            <summary>
            fires when the size of the cube tigthly enclosing the shape has changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Invalidated">
            <summary>
            fires when the (size)cache of the node was invalidated
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Visible">
            <summary>
            Get/set visiblility for the scene graph branch 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Parent">
            <summary>
            reference to the scene graph node this node is a child of
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.PositionMin">
            <summary>
            the minimum coordinate of a cube tightly enclosing the node (and all childs) 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.PositionMax">
            <summary>
            the maximum coordinate of a cube tightly enclosing the node (and all childs) 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Center">
            <summary>
            current geometric center according of scene graph branch
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Add(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            add a single node to the end of child collection
            </summary>
            <param name="item">node to add </param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Clear">
            <summary>
            wipe all nodes from the collection 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Contains(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            Determine, if this collection contains a specific node item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Remove(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            remove a single child node from the collection
            </summary>
            <param name="item">node to be removed</param>
            <returns>true</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Count">
            <summary>
            Number of children contained in this node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.IsReadOnly">
            <summary>
            determine if this collection is readonly, (returns 'false')
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Computation.GetSortedIndices(ILNumerics.ILArray{System.Single},ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            compute distance to camera and return sorted indices for rendering
            </summary>
            <param name="centers">current primitive centers</param>
            <param name="position">current camera position</param>
            <returns>sorted indices of primitives in descending order</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILPanelConfigurator.ConfigurePanel(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            Implemented by custom graph objects, configures the hosting panel according to requirements of specific plot type
            </summary>
            <param name="panel">the panel to be configured</param>
        </member>
        <member name="F:ILNumerics.Drawing.Plots.ILVectorField2D.m_colormap">
            <summary>
            Colormap used to map values to colors
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.Drawing.Misc.ILColormap,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <summary>
            create new vector field (2D) plot 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="data">3d data array: :;:;0 - X coords of vectors, :;:;1 - Y coords</param>
            <param name="colormap">Colormap used for coloring, on null: Colormaps.ILNumerics is used as default</param>
            <param name="XLabels">labels for X axis, on null: auto labeling</param>
            <param name="YLabels">labels for Y axis, on null: auto labeling</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.Configure">
            <summary>
            (internal use) reconfigures the plot after changes
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.ConfigurePanel(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            configure the panel, called after the plot was added to the scene
            </summary>
            <param name="panel"></param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.Data">
            <summary>
            gets reference to data of all vectors or sets it (restricted to same size)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.Colormap">
            <summary>
            get the colormap used for coloring the arrows or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.ArrowHeadAngle">
            <summary>
            opening angle for the arrow heads, default: 5 deg
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.ArrowScale">
            <summary>
            Scaling of arrow length, 1.0: full size; default: 0.9
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.LinesShape">
            <summary>
            enables access to the lines composite shape used for rendering
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.XLabels">
            <summary>
            collection of label texts for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.YLabels">
            <summary>
            collection of label texts for y axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.Computation.CreateTestData(System.Int32,System.Int32,System.Single)">
            <summary>
            create data for a simple vector field for demonstration purposes
            </summary>
            <param name="numRows">number of rows</param>
            <param name="numCols">number of colums</param>
            <param name="offs">offset, linearly varing values lets the field 'roll'</param>
            <returns>three dimensional data array</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLAxis">
            <summary>
            OpenGL implementation for ILAxis 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxis">
            <summary>
            Axis object for ILPanel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.OnChange">
            <summary>
            fires a changed event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.m_clipping_Changed(System.Object,ILNumerics.Drawing.ClippingChangedEventArgs)">
            <summary>
            occures if the registered clipping data have changed
            </summary>
            <param name="sender">ILClipping data</param>
            <param name="e">clipping changed event args</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.#ctor(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            construct ILAxis object. This contructor is not to be called directly.
            </summary>
            <param name="name">type of the axis: XAxis,YAxis,ZAxis</param>
            <param name="clippingView">Clipping data to be registered into the axis.</param>
            <param name="layoutData">additional layout data, does currently only contain the camera [depricated]</param>
            <param name="panel">panel hosting the scene</param>
            <remarks>ILAxis objects are created GL-device dependend by use of a device dependend ILPanel instance's
            member ILPanel.CreateAxis(). This acts like a factory pattern. The specific axis derivate will be
            created by the derived ILPanel object (ILDXPanel or ILOGLPanel).</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            this function does the drawing of the axis lines 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw background only, false: draw foreground only</param>
            <remarks>This function is called in the general rendering algorithm. I.e. <b>before</b> the surface buffers has been swapped.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawLabel(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) do the drawing of axis' label 
            </summary>
            <param name="p">render properties</param>
            <remarks>When this function is called, depends on the DrawAfterBufferSwaped setting 
            of the current TextRenderer.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawTickLabels(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) draw tick labels
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.drawGrid">
            <summary>
            Do all rendering for the grid of the axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState1(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw this axis in the back (behind the graphs)
            </summary>
            <param name="p">render properties</param>
            <remarks>This method is used internally. There should be no need to call it directly.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Do rendering of foreground (before the graphs)
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState3(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            do rendering after the buffers have been swapped
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Configure(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            update axis (recalculate number &amp; position of labels in auto mode, recreate vertices)
            </summary>
            <param name="p">render properties</param>
            <remarks>This method is used internally. There should be no need to call it directly.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.PrepareMeshes(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            recreate vertices
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.PrepareLabels(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            recreate labels
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.GetMaxTickCount(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            number of ticks optimally fitting on screen
            </summary>
            <param name="p">render properties</param>
            <returns>optimal number of ticks for this axis</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.countPrimitves">
            <summary>
            determine number of primitives (lines) to be drawn for this axis
            </summary>
            <returns>number of primitives</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Invalidate">
            <summary>
            Invalidate this axis, causes recreation on next render
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Dispose">
            <summary>
            (internal use) dispose off this axis' elements
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Panel">
            <summary>
            Panel hosting the axis (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.LabeledTickProvider">
            <summary>
            Used to retrieve/specify the delegate computing nice labels for axis
            </summary>
            <remarks>One can replace the default tick provider by a user 
            defined labeled tick computation function. Therefore simply set this property to
            your own ILLabeledTickProvider function.
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.FarLines">
            <summary>
            get properties for far axis lines (opposite label side) or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.NearLines">
            <summary>
            get properties for near axis lines (opposite label side) or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Label">
            <summary>
            label to be displayed next to this axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Visible">
            <summary>
            Switch visibility on/ off
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.AxisType">
            <summary>
            axis type
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.LabeledTicks">
            <summary>
            Gives access to the collection of labeled ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.UnlabeledTicks">
            <summary>
            access to the collection of unlabeled ticks (not used)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Index">
            <summary>
            access to a specific axis by number 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Grid">
            <summary>
            access grid lines properties 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Limits">
            <summary>
            access axis limits 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layout">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the x axis 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILShapeLabel">
            <summary>
            a label used for labeling shapes (screen coords, defined via world coords)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILLabelingElement">
            <summary>
            Base class for text elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Drawing.Font,System.Drawing.Color)">
            <summary>
            [abstract] Create a new labeling element 
            </summary>
            <param name="panel">panel hosting the element</param>
            <param name="font">default font for the element</param>
            <param name="color">default color for the element</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.CoordSystem)">
            <summary>
            [abstract] Create a new labeling element 
            </summary>
            <param name="panel">panel hosting the element</param>
            <param name="font">default font for the element</param>
            <param name="color">default color for the element</param>
            <param name="coordSystem">world / screen rendering method</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.Dispose">
            <summary>
            Dispose off this element's ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.m_renderer_CacheCleared(System.Object,System.EventArgs)">
            <summary>
            if the renderer cleares its cache, the expression needs to be re-interpreted
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size,System.Drawing.Point@)">
            <summary>
            add offset to an existing point according to internal alignment
            </summary>
            <param name="size">size of content to be aligned</param>
            <param name="point">original point</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size)">
            <summary>
            return offset according to current setting of m_alignment
            </summary>
            <param name="size">size of an element to align</param>
            <returns>offset according to Alignment property</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size,System.Drawing.Point)">
            <summary>
            return offset according to current setting of m_alignment
            </summary>
            <param name="size">size of an element to align</param>
            <param name="p">point inside rectangle of size 'size'</param>
            <returns>offset according to Alignment property</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.interprete(System.String)">
            <summary>
            interprete the expression and cache render queue
            </summary>
            <param name="expression"></param>
        </member>
        <member name="E:ILNumerics.Drawing.Labeling.ILLabelingElement.Changed">
            <summary>
            fires when an element's property has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Size">
            <summary>
            Size of the label for rendering, regardless of orientation
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Color">
            <summary>
            color used to display the element
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Font">
            <summary>
            Get/set system font used to draw the text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Orientation">
            <summary>
            Get the orientation for the labeling element or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Anchor">
            <summary>
            Get/set the relative offset of the 'Position' point rel. to the overall label size, range 0..1 for X and Y 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Interpreter">
            <summary>
            Text interpreter used to transform labeling source into bitmap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Renderer">
            <summary>
            device dependent renderer, used to draw the labeling bitmap onto panel
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Text">
            <summary>
            Get / set the text expression defining the content to be displayed 
            </summary>
            <remarks><para>The expression may contain markups according to 
            the specific interpreter instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            (internal use)
            </summary>
            <param name="p">render properties</param>
            <param name="center">center position for the label</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.drawFringed(ILNumerics.Drawing.Interfaces.IILTextRenderer,System.Object,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            draws a fringe around the render output in fringe color
            </summary>
            <param name="m_renderer"></param>
            <param name="m_rendererQueue"></param>
            <param name="dest"></param>
            <param name="textOrientation"></param>
            <param name="m_color"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            (internal use)
            </summary>
            <param name="p">render properties</param>
            <param name="min">minimum coord for label area</param>
            <param name="max">maximum coord for label area</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILShapeLabel.FringeColor">
            <summary>
            get/set the color used for drawing a fringe around glyphs, empty: no fringe
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitTriangle">
            <summary>
            A single simple bordered triangle supporting light
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitBorderedShape`1">
            <summary>
            Base class for all simple, bordered shapes to be used within ILNumerics.Drawing scene graphs
            </summary>
            <typeparam name="VertexType"></typeparam>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILBorderedShape`1">
            <summary>
            Base class for all simple shapes, rendering a primitive 
            with a border, which is independantly configurable. 
            </summary>
            <typeparam name="VertexType">inner vertex element type (struct)</typeparam>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILShape`1">
            <summary>
            abstract generic shape, specific vertex type
            </summary>
            <typeparam name="VertexType">the internal vertex type, IILVertexDefinition</typeparam>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILShape">
            <summary>
            abstract base class for all shapes 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create new shape (protected) 
            </summary>
            <param name="panel">panel hosting the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Dispose">
            <summary>
            may be overwritten in derived classes to clean up ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.GetVertex(System.Int32)">
            <summary>
            Query single vertex via IILVertexDefinition interface 
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <returns>vertex definition</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetColor(System.Int32,System.Drawing.Color)">
            <summary>
            set color for single vertex (color only, no alpha!)
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="color">new color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetPosition(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set position if single vertex 
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="position">new position </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetNormal(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set normal vector for single vertex
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="normal">new normal vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetVertex(System.Int32,ILNumerics.Drawing.Interfaces.IILVertexDefinition)">
            <summary>
            alter single vertex via IILVertexDefinition interface
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="vertex">new vertex definition</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Translate(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            translate all vertices of the shape
            </summary>
            <param name="offset">offset, all vertices will be moved by that amount</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw this shape (internal use) 
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Configure">
            <summary>
            configure this shape (internal use)
            </summary>
            <remarks>Configure is called once for each rendering frame. If the shape 
            is invalidated, this causes IntConfigure to be called on the shape.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Invalidate">
            <summary>
            Invalidates this shape, needed after altering any vertex data
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Shapes.ILShape.Changed">
            <summary>
            fires, when any properties of the shape have changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Shapes.ILShape.SizeChanged">
            <summary>
            fires when the size of the shape has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Visible">
            <summary>
            Gets visibility of the shape or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.SceneGraphNode">
            <summary>
            returns the scene graph node holding this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.PositionMin">
            <summary>
            Get minimum coordinate of the cube enclosing the shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.PositionMax">
            <summary>
            Get maximum coordinate of the cube enclosing the shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Center">
            <summary>
            Get weight center of vertices 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Shading">
            <summary>
            Get/set method of area filling 
            </summary>
            <remarks><para>Two methods are available: 'Interpolate' and 'Flat'. For 'Interpolate' mode,
            the color and alpha values stored in individual vertices are used for rendering. 
            In 'Flat' mode, only the single properties 'FillColor' and 'Opacity' determine 
            the color and transparency of the whole shape. Even if vertices store individual
            color values, those are ignored in that case.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.FillColor">
            <summary>
            fill color for shape areas in flat shading mode
            </summary>
            <remarks>Setting this value will not alter the alpha value 
            (opacity). The alpha of the new value will be ignored.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.VertexDefinition">
            <summary>
            definition of internal vertex type (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Opacity">
            <summary>
            opacity for areas of the shape in flat shading mode 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Label">
            <summary>
            Shape label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount">
            <summary>
            number of vertices a shape (or all components of a shape) of this type is made out of
            </summary>
            <remarks>For triangle shapes and related (lit triangles, triangles etc.) this is 3, for quads it is 4 and so on...</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.GetVertex(System.Int32)">
            <summary>
            Query single vertex via IILVertexDefinition interface 
            </summary>
            <param name="i">index of vertex in vertex array</param>
            <returns>vertex definition</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetVertex(System.Int32,ILNumerics.Drawing.Interfaces.IILVertexDefinition)">
            <summary>
            alter single vertex via IILVertexDefinition interface
            </summary>
            <param name="vertexIdx">index of vertex in vertex array</param>
            <param name="vertex">new vertex definition</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetColor(System.Int32,System.Drawing.Color)">
            <summary>
            set color for single vertex (color only, no alpha!)
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="color">new color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetPosition(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set position of single vertex 
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="position">new position </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetNormal(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set normal vector of single vertex
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="normal">new normal vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.Translate(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            translate all vertices of the shape
            </summary>
            <param name="offset">offset, all vertices will be moved by that amount</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.Vertices">
            <summary>
            access to internal vertex array
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape">
            <summary>
            number of vertices per shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.CustomCenter">
            <summary>
            get or manually define the center of the shape
            </summary>
            <remarks>Once an individual (custom) center was assigned to the CustomCenter
            property, that point is returned and used on subsequent queries for Center. 
            <para>In order to clear the custom center, set the CustomCenter property to ILPoint3Df.Emtpy.</para>
            <para>The center is important to position the shape in the scene - according to 
            other shapes. This defines the order in which the shapes are rendered, which 
            is neccessary for transparency to appear correctly. In general one should
            not alter the center. This will compute the center of a shape accordingly to its 
            real vertices weight average. However, for certain special shapes it might 
            be helpful to override the center to manually determine the rendering order in the scene.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.VertexDefinition">
            <summary>
            internal vertex definition (readonly)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILBorderedShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create new bordered shape
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of vertices, this bordered shape will be made out of</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILBorderedShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create new bordered shape, provide initial vertex data
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="X">X coordinates, vector of length 'VertexCount'</param>
            <param name="Y">Y coordinates, vector of length 'VertexCount'</param>
            <param name="Z">Z coordinates, vector of length 'VertexCount'</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILBorderedShape`1.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update vertices of the shape
            </summary>
            <param name="X">X positions vector</param>
            <param name="Y">Y positions vector</param>
            <param name="Z">Z positions vector</param>
            <remarks>Updates are made to the positions of the vectors only. X, Y and Z must be 
            vectors of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILBorderedShape`1.Border">
            <summary>
            get reference to the properties of the shapes border 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitQuad">
            <summary>
            A single simple bordered quad supporting light
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_renderIndices">
            <summary>
            actual indices used for rendering (sorted for translucent shapes)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_shapeIndices">
            <summary>
            cache indices defining each shapes corners
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_oldCameraPosition">
            <summary>
            cache camera position of last sorting
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32,System.Int32)">
            <summary>
            create composite shape
            </summary>
            <param name="panel">scene hosting the scene</param>
            <param name="numVertices">number of overall vertices for the shape</param>
            <param name="verticesPerShape">Number of vertices per shape</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create composite shape 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="verticesPerShape">number of vertices per shape</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <remarks>The constructor creates a new composite shape out of all vertices specified in X,Y and Z.
            Every vertex is only used once. Every shape uses 
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> vertices one after another.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create composite shape 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="verticesPerShape">number of vertices per shape</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having  
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> elements in a column therefore 
            compose a single shape. Vertices may get used arbitrary times (or not at all). All elements must be 
            positive integer values in range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create composite shape 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="verticesPerShape">number of vertices per shape</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having  
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> elements in a column therefore 
            compose a single shape. Vertices may get used arbitrary times (or not at all). All elements must be 
            positive integer values in range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update composite shape 
            </summary>
            <param name="X">x coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Y">y coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Z">z coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <remarks>All vertices of the shape are updated with the data specified in X,Y and Z. Neither the mapping of shapes 
            nor the colors or any other data of vertices are changed. The shape is invalidated than. </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update composite shape
            </summary>
            <param name="X">x coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Y">y coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Z">z coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having  
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> elements in a column therefore 
            compose a single shape. Vertices may get used arbitrary times (or not at all). All elements must be 
            positive integer values in range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
            <remarks>All vertices of the shape are updated with the data specified in X,Y and Z. Neither the colors or any 
            other data of vertices are changed. The shape is invalidated for reconfiguration at next redraw. </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update composite shape
            </summary>
            <param name="X">x coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Y">y coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="Z">z coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> elements in a column therefore
            compose a single shape. Vertices may get used arbitrary times (or not at all). All elements must be
            positive integer values in range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
            <param name="colors">The colors.</param>
            <remarks>All vertices of the shape are updated with the data specified in X,Y and Z. Neither the colors or any
            other data of vertices are changed. The shape is invalidated for reconfiguration at next redraw. </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Indices">
            <summary>
            Indices used to render primitives from vertices 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILPlot2DGraph">
            <summary>
            2D line &amp; point graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILGraph">
            <summary>
            graph for drawings into ILPanel
            </summary>
            <remarks>Use the ILGraphCollection returned from ILPanel.Graphs and its Add... functions to create new graphs.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Configure">
            <summary>
            configures all parameters + cache, called before drawing
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Invalidate">
            <summary>
            invalidate and recalculate this graphs data, this must be called after changes to relevant graph properties
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the graph into the panel
            </summary>
            <param name="p">extended drawing properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Dispose">
            <summary>
            clear ressources of the graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Is3DGraph">
            <summary>
            determine general type of graph (2D/3D) 
            </summary>
            <returns>true for 3D graphs (f.e. surf, scene graph) and false for 2D graphs (plot2D)</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Label">
            <summary>
             the label of the graph (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Limits">
            <summary>
            data limits of the graphs current data (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Type">
            <summary>
            The type of graph (Plot2D, Surf, ImageSC, ...)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Panel">
            <summary>
            The hosting panel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILLegendRenderer.DrawToLegend(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            draws a small example of the visual output 
            </summary>
            <param name="p">extended render properties</param>
            <param name="sampleArea">area to draw the line + marker into</param>
            <param name="labelArea">area to draw corresponding label into</param>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILLegendRenderer.LabelSize">
            <summary>
            Size of text label
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Invalidate">
            <summary>
            Invalidate the graph after vertex data have been changed.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.DrawToLegend(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            draws a small example of the visual output 
            </summary>
            <param name="p">render properties</param>
            <param name="sampleArea">area to draw the line + marker into</param>
            <param name="labelArea">area to draw corresponding label into</param>
            <remarks>derived classes implement this for current device contexts</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.Drawing.ILClippingData)">
            <summary>
            [internal] constructor - do not use this! Use ILPanel.Graphs.Add...() instead!
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="sourceArray">data array</param>
            <param name="clippingContainer">hosting panels clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.Drawing.ILClippingData)">
            <summary>
            [internal] constructor - do not use this! Use ILPanel.Graphs.Add...() instead!
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="XData">x data array</param>
            <param name="YData">y data array</param>
            <param name="clippingContainer">hosting panels clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.m_marker_Changed(System.Object,System.EventArgs)">
            <summary>
            called, if a property for markers have changed
            </summary>
            <param name="sender">this graph instance</param>
            <param name="e">(no args)</param>
            <remarks>derived classes should override this function in order to 
            (re-)configure vertex ressources etc.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.m_properties_Changed(System.Object,System.EventArgs)">
            <summary>
            called, if a property for lines have changed
            </summary>
            <param name="sender">this graph instance</param>
            <param name="e">(no args)</param>
            <remarks>derived classes should override this function in order to 
            (re-)configure vertex ressources etc.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.AutoLimitsUpdateCount">
            <summary>
            number of subsequent updates ('Queue') before limits get recalculated. Default: 0 (recalculate on every update)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Line">
            <summary>
            Get properties of lines
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Marker">
            <summary>
            Get properties of markers
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Vertices">
            <summary>
            access to internal vertex array
            </summary>
            <remarks><para>after altering vertex data, one must call 
            Invalidate() to signal those changes.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.LabelSize">
            <summary>
            Size of label
            </summary>
            <value>size</value>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILVertexDefinition">
            <summary>
            definition of vertex data &amp; properties
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresAlpha">
            <summary>
            determine, if the vertex is able to store individual alpha values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresColor">
            <summary>
            determine, if the vertex is able to store individual color values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresNormals">
            <summary>
            determine, if the vertex is able to store normal data 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Alpha">
            <summary>
            Get/set the alpha value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Color">
            <summary>
            Set the color for the vertex, alpha value is not modified!
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Position">
            <summary>
            get/set position (X,Y,Z values) for the vertex 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Normal">
            <summary>
            Get/set the normal vector for the value (see also: AutoCalculateNormals) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.XPosition">
            <summary>
            get/set the X coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.YPosition">
            <summary>
            get/set the Y coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.ZPosition">
            <summary>
            get/set the Z coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.VertexSize">
            <summary>
            size of single vertex in bytes
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILDrawingException">
            <summary>
            Drawing exception
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawingException.#ctor(System.String)">
            <summary>
            create new drawing exception
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawingException.#ctor(System.String,System.Exception)">
            <summary>
            create new drawing exception
            </summary>
            <param name="message">message</param>
            <param name="innerException">inner (nested) exception</param>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILSubfigureCollection">
            <summary>
            Collection of all subfigures contained in an ILFigureControl
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.#ctor">
            <summary>
            create new ILSubfigureCollection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Add(System.Int32,ILNumerics.Drawing.Controls.ILSubfigure)">
            <summary>
            Add subfigure to subfigure collection
            </summary>
            <param name="key">the key to identify the new subfigure</param>
            <param name="subfigure">the new subfigure</param>
            <remarks>If a subfigure with the key already exist in the collection, 
            it will be replaced by the new subfigure</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Contains(System.Int32)">
            <summary>
            Determine if a subfigure with the key given exist
            </summary>
            <param name="key">key of subfigure</param>
            <returns>true if a subfigure with the given key exists, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Purge(System.Int32)">
            <summary>
            Reduce the number of subfigures to the given number
            </summary>
            <param name="number">number of subfigures to remain</param>
            <remarks>If more than number subfigures exist, they will be removed. Highest keys will be removed first.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Item(System.Int32)">
            <summary>
            Get / set subfigure by key
            </summary>
            <param name="key">key of subfigure</param>
            <returns>subfigure specified by key</returns>
            <value>subfigure to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Count">
            <summary>
            number of subfigures currently stored in the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Keys">
            <summary>
            get all keys for all subfigures as key collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Figures">
            <summary>
            Get all subfigures as value collection
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer">
            <summary>
            Basic OpenGL implementation for IILTextRenderer
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILTextRenderer">
            <summary>
            interface for all classes capable of renderung (device 
            dependend) texts into plot panels 
            </summary>
            <remarks>class definitions should also implement the ILRendererAttribute. See <see cref="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer"/> for an example.</remarks>
            <seealso cref="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer"/>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Begin(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            begins drawing, to be called before Draw()!
            </summary>
            <param name="p">extended render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Begin(ILNumerics.Drawing.ILRenderProperties,System.Double[]@)">
            <summary>
            begins drawing and queries current model view matrix also
            </summary>
            <param name="p">extended render properties</param>
            <param name="modelview">current modelviewmatrix</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            Draw the text (screen coords)
            </summary>
            <param name="renderQueue">contains items to be drawn</param>
            <param name="position">position relative to surface, starting point for drawing</param>
            <param name="orientation">orientation for item</param>
            <param name="color">initial or default color</param>
            <remarks>
            	<para>Before calling Draw(), the TextRenderer must have been initialized with Begin(g)!</para>
            	<para>use this function if drawing in screen coords, the size for render
            output will be taken from the Size member of the render queue (pixels).</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">on attempt to draw any text without previous initialization</exception>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Drawing.Color)">
            <summary>
            Draws the text in world coords 
            </summary>
            <param name="renderQueue">contains items to be drawn</param>
            <param name="x1">x1-position</param>
            <param name="y1">y1-position</param>
            <param name="z1">z1-position</param>
            <param name="x2">x2-position</param>
            <param name="y2">y2-position</param>
            <param name="z2">z2-position</param>
            <param name="color">base color for items not containing individual colors</param>
            <remarks>
            <para>Before calling Draw(), the TextRenderer must have been initialized with Begin(g)!</para>
            <para>Use this function to draw the render queue in world coords. The position parameters mark the upper left 
            and lower right corner of the quads to contain the render queue content.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">on attempt to draw any text without previous initialization</exception>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.End(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            finalizes the drawing (must prepare it again before drawing!)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Cache single item into the renderer cache. 
            </summary>
            <param name="key">key used to uniquely identify the item in cache</param>
            <param name="bmp">item bitmap data</param>
            <param name="rect">section in bmp to be transfered into the cache</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.ExistsKey(System.String)">
            <summary>
            test if an item for a specific key is already cached
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            test if the key exists and return the size of corresponding item on success
            </summary>
            <param name="key">key identifying the item</param>
            <param name="size">if the key was found: the size of the corresponding item</param>
            <returns>true, if the key exist, false otherwise</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.Name">
            <summary>
            The name of the TextRenderer instance (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.NameLong">
            <summary>
            A more descriptive name to be displayed into GUI's (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.DeviceType">
            <summary>
            Get the graphics device type this TextRenderer instance 
            is capable to use for drawing 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.DrawAfterBufferSwapped">
            <summary>
            Determine, if the text is to be drawn after the rendering 
            backbuffer has been swapped and presented to the screen. (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.Cached">
            <summary>
            Determine, if this renderer chaches the output (implementation dependent) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.CoordSystem">
            <summary>
            Determine the coord system this renderer is specialized to draw in
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.ColorOverride">
            <summary>
            if set to a color (not Color.Empty), that color will be used for all renderings. 
            The color contained in the rendering queue is ignored than.
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Interfaces.IILTextRenderer.CacheCleared">
            <summary>
            for cached renderers, fires if the internal cache was cleared
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Place a new item into the texture cache 
            </summary>
            <param name="key">unique key to identify the item for later reference</param>
            <param name="bmp">bitmap containing the item data</param>
            <param name="rect">area in <paramref name="bmp"/> containing the item's data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.ExistsKey(System.String)">
            <summary>
            Test if the cache contains an item with a specific key
            </summary>
            <param name="key">key</param>
            <returns>true if the item was cached, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            try to get the size (screen pixels) of an item
            </summary>
            <param name="key">unique key identifying the item</param>
            <param name="size">[output] size of the item (if found)</param>
            <returns>true, if the item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Drawing.Color)">
            <summary>
            Draws all items contained in a given render queue
            </summary>
            <param name="queue">render queue</param>
            <param name="x1">x1-position</param>
            <param name="y1">y1-position</param>
            <param name="z1">z1-position</param>
            <param name="x2">x2-position</param>
            <param name="y2">y2-position</param>
            <param name="z2">z2-position</param>
            <param name="color">base color for items not containing individual colors</param>
            <remarks><para>The render queue must contain only keys for already cached items!</para>
            <para>The color parameter serves as a global color definition. It may be overwritten 
            by individual color specifications of the queue items.</para>
            <para>Use this function to draw the render queue in world coords. The position parameters mark the upper left 
            and lower right corner of the quads to contain the render queue content.</para>
            </remarks>
        </member>
        <member name="E:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.CacheCleared">
            <summary>
            fires when the texture storage has been cleared 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Misc.ILColorEnumerator">
            <summary>
            enumerate colors 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
            create new color enumeration based on a specific colormap
            </summary>
            <param name="basemap"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.#ctor">
            <summary>
            create new color enumerator based on Colormap.Lines
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.NextColor">
            <summary>
            return next color and increase internal pointer
            </summary>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Drawing.AutoZoomOptions">
            <summary>
            Options for adapting ILPanel view limits 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.Never">
            <summary>
            never adapt automatically, the view limits are handled by the user
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.OnStartup">
            <summary>
            Only adapt view limits once at startup, later changes of the data limits will not affect the view limits
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.OnDataChanges">
            <summary>
            View limits will automatically adapt changes of data limits. (Default)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AspectRatioMode">
            <summary>
            modes for projecting the rendering output to the available client area
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.StretchToFill">
            <summary>
            plots fill available rendering area of the PlotCubeScreenRectF rectangle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.MaintainRatios">
            <summary>
            plots will be shrinked to fit inside PlotCubeScreeRectF but maintain data aspect ratio
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ZoomModes">
            <summary>
            defines the movement from current to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.Jump">
            <summary>
            No ramp, jump to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollSoft">
            <summary>
            morph softly to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollHard">
            <summary>
            morph faster to new setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollOverride">
            <summary>
            morph to new setting by 'going over the limit'
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Colormaps">
            <summary>
            predefined colormaps
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TextOrientation">
            <summary>
            Orientation for labels and other purposes
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.VerticalAlignment">
            <summary>
            Alignment for 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickLabelRenderingHint">
            <summary>
            Suggest, how label positions for axis ticks are to be choosen
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Filled">
            <summary>
            tick labels will optimally fill the whole axis length
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple1">
            <summary>
            multiples of 10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple2">
            <summary>
            multiples of 2*10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple5">
            <summary>
            multiples of 5*10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Auto">
            <summary>
            Try to find the optimal division for tick label steps [default]
            </summary>
            <remarks>This method is the most computational intensive one.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.AxisNames">
            <summary>
            Names for all 3 axes 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.UnlabeledTick">
            <summary>
            simple single unlabled tick
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.UnlabeledTick.Position">
            <summary>
            Position of tick
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AxisType">
            <summary>
            Axis ticks spacing type: linear, logarithmic
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisType.Linear">
            <summary>
            linear axis tick spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisType.Logarithmic">
            <summary>
            logarithmic axis tick spacing
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickDisplay">
            <summary>
            On which sides ticks will be displayed
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDisplay.LabelSide">
            <summary>
            ticks for axis will be displayed on label side only
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDisplay.BothSides">
            <summary>
            ticks for axis will be displayed on label - and the opposite site 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickDirection">
            <summary>
            how ticks are displayed (inside/outside)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDirection.Inside">
            <summary>
            Ticks will lay inside the rendering cube
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDirection.Outside">
            <summary>
            Ticks will lay outside the rendering cube
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxisLabelOrientation">
            <summary>
            orientation for axis labels (not implemented)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickMode">
            <summary>
            TickModes - automatic or manual axis tick positioning
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Auto">
            <summary>
            find tick positions automatically 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Manual">
            <summary>
            manually create ticks 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.PlotBoxScreenSizeMode">
            <summary>
            options for the sizing of the projection of the plot cube onto the 2D screen client area of the control
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Maximum">
            <summary>
            the projection of the plot cube drawing area fills the whole controls space (labels may be hidden) 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Optimal">
            <summary>
            the size of plot cube projection rectangle is automatically determined, taking labels size into account
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.StrictOptimal">
            <summary>
            more pixel exact positioning, strictly only the place really needed for labels is used (slower)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Manual">
            <summary>
            No automatic resizing for the cube projection size, values from PlotCubeScreenRect are taken
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderReason">
            <summary>
            possible states/reasons/sources for rendering the scene
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderReason.PaintEvent">
            <summary>
            normal source, the scene is to be rendered the common way
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderReason.RecalcLabels">
            <summary>
            the rendering was re-initialized because the matrices need to be recalculated for laying out labels correctly 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LabelAlign">
            <summary>
            Alignments for labels 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Lower">
            <summary>
            align the label near the lower range limit
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Center">
            <summary>
            align the label in the center 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Upper">
            <summary>
            align the label near the upper range limit
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickLabelAlign">
            <summary>
            Possible alignments for tick labels
            </summary>
            <remarks>member of this enum can get bitwise combined. Default is: Top,Left</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.left">
            <summary>
            align the label to the left side
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.center">
            <summary>
            align the labels to the center
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.right">
            <summary>
            align the label to the right side
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.top">
            <summary>
            align the label to top
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.vertCenter">
            <summary>
            align the label to center vertically 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.bottom">
            <summary>
            align the label to bottom
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Projection">
            <summary>
            projection types
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Perspective">
            <summary>
            3D graphs will be distorted for opotimized 3D impression
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Orthographic">
            <summary>
            graphs will not be distorted. objects in the front will get the same size as objects in the back
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.MarkerStyle">
            <summary>
            valid marker styles (partially supported)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Dot">
            <summary>
            draw markers as dots
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Circle">
            <summary>
            draw markers as circle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Diamond">
            <summary>
            draw markers as diamonds
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Square">
            <summary>
            draw markers as square
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleUp">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleDown">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleLeft">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleRight">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Plus">
            <summary>
            draw markers as plus
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Cross">
            <summary>
            draw markers as cross
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.None">
            <summary>
            do not draw markers
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CameraQuadrant">
            <summary>
            Possible positions of the camera
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ShadingStyles">
            <summary>
            Shading styles for surface graphs
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ShadingStyles.Interpolate">
            <summary>
            color will be interpolated between all corners 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ShadingStyles.Flat">
            <summary>
            same color for whole tile area
            </summary>
            <remarks>The resulting color will 
            reflect the average over all corner values for a rectangle</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.LineStyle">
            <summary>
            line style
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Solid">
            <summary>
            solid line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Dashed">
            <summary>
            dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.PointDash">
            <summary>
            point dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Dotted">
            <summary>
            dotted line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.UserPattern">
            <summary>
            use user stipple pattern 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.None">
            <summary>
            no line at all
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.InteractiveModes">
            <summary>
            Mouse interaction mode for subfigures (not implemented yet)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILPoint3Df">
            <summary>
            single precision 3D point structure
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.X">
            <summary>
            X coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.Y">
            <summary>
            Y coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.Z">
            <summary>
            Z coordinate
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            create point in single precision
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coord</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            create new ILPoint3Df by double values (for convenience, internally casted to float)
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coors</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.ToString">
            <summary>
            convert this point to string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.cross(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product between a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.crossN(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            normalized cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product: a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.Spin(ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            rotate the vector, keep length
            </summary>
            <param name="normal">axis as rotation normal</param>
            <param name="angleDeg">angle to move (radian)</param>
            <returns>rotated version of this vector, does not change original vector</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.Equals(System.Object)">
            <summary>
            Compares obj's coordinate values to those of this class instance
            </summary>
            <param name="obj">ILPoint3Df to compare</param>
            <returns>true, if X,Y and Z coordinates are equal</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.GetHashCode">
            <summary>
            get a hash code for this ILPoint3Df object
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILPoint3Df.Item(System.Int32)">
            <summary>
            Access to coords by index
            </summary>
            <param name="index">index number: 0=x, 1=y, 2=z</param>
            <returns>float value of coord specified</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ILPoint3Dd">
            <summary>
            double precision 3D point definition
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.X">
            <summary>
            X coord
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.Y">
            <summary>
            Y coord
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.Z">
            <summary>
            Z coord
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphicDeviceType">
            <summary>
            supported graphics devices
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.Direct3D">
            <summary>
            DirectX based 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.OpenGL">
            <summary>
            OpenGL based (not supported yet)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.GDI">
            <summary>
            Windows native graphics device (not implemented)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.Unknown">
            <summary>
            unknown graphics device (not used, errror)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphType">
            <summary>
            valid types for plotting graphs
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CoordSystem">
            <summary>
            Coordinate systems for TextRenderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CoordSystem.Screen">
            <summary>
            the location is expected to be specified into screen coords
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CoordSystem.World3D">
            <summary>
            the location is expected to be specified into world (3D) coords
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderItemType">
            <summary>
            possible types of renderable items 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Character">
            <summary>
            the item defines a character 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Bitmap">
            <summary>
            the item defines a bitmap
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphCollectionChangeReason">
            <summary>
            possible reason for an ILGraphCollectionChangedEvent to occur
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.LabeledTick">
            <summary>
            simple single labeled tick
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.LabeledTick.Queue">
            <summary>
            tick label
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.LabeledTick.Position">
            <summary>
            tick position
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.LabeledTick.#ctor(System.Single,ILNumerics.Drawing.Labeling.ILRenderQueue)">
            <summary>
            create single labeled tick
            </summary>
            <param name="position">position</param>
            <param name="queue">render queue used to render the item</param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleInterpreter">
            <summary>
            Transforms characters into bitmaps (1:1)
            </summary>
            <remarks>this is the base class for most IILTextInterpreter implementations</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILTextInterpreter">
            <summary>
            interface for classes capable of transforming text 
            expressions into visual output representation
            </summary>
            <seealso cref="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter"/>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextInterpreter.Transform(System.String,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.Interfaces.IILTextRenderer)">
            <summary>
            transform text element (text) into bitmap for rendering
            </summary>
            <param name="expression">item text expression, defines the visual output content</param>
            <param name="font">font used for rendering the text</param>
            <param name="color">initial color, unless overridden, used for items in expression</param>
            <param name="renderer">IILTextRenderer implementation, used for caching the element(s)</param>
            <returns>renderer queue, contains item keys and the size of transformed item expression</returns>
            <remarks>The implementation should use the general caching capabilities 
            of the renderer class. Therefore the item's elements must be cached subsequently
            into the renderer before drawing. The render queue returned may be 
            used for rendering in the same renderer than.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.#ctor">
            <summary>
            create a new instance of this text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.TransformItem(System.String,System.Drawing.Font,System.Drawing.RectangleF@)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="size">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.transformItem(System.String,System.Drawing.Font,System.Drawing.RectangleF@)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="size">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.Interfaces.IILTextRenderer)">
            <summary>
            Transforms an expression into render queue definition
            </summary>
            <param name="expression">expression to be transformed</param>
            <param name="font">font may used for transformation</param>
            <param name="color">standard color used for transformation</param>
            <param name="renderer">IILTextRenderer instance used for caching (and later rendering)</param>
            <returns>render queue, later used to render the visual representation of the expression</returns>
            <remarks>the expression may contain markups. See the online help at http://ilnumerics.net
            for a detailed descriptioin of known symbols and their syntax.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String,System.Drawing.Font)">
            <summary>
            Render text expression into bitmap
            </summary>
            <param name="expression">text expression</param>
            <param name="font">font used for rendering</param>
            <returns>Bitmap with rendered expression</returns>
            <remarks>The size of the bitmap returned will tightly fit around the rendered content.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String)">
            <summary>
            Render text expression into bitmap
            </summary>
            <param name="expression">text expression</param>
            <returns>Bitmap with rendered expression</returns>
            <remarks>The size of the bitmap returned will tightly fit around the rendered content. 
            <para>A generic sans serif font of size 10em will be used. </para></remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer">
            <summary>
            OpenGL text renderer in screen coords
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Place a new item into the texture cache 
            </summary>
            <param name="key">unique key to identify the item for later reference</param>
            <param name="bmp">bitmap containing the item data</param>
            <param name="rect">area in <paramref name="bmp"/> containing the item's data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.ExistsKey(System.String)">
            <summary>
            Test if the cache contains an item with a specific key
            </summary>
            <param name="key">key</param>
            <returns>true if the item was cached, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            try to get the size (screen pixels) of an item
            </summary>
            <param name="key">unique key identifying the item</param>
            <param name="size">[output] size of the item (if found)</param>
            <returns>true, if the item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            Draws all items contained in a given render queue
            </summary>
            <param name="queue">render queue</param>
            <param name="location">starting point</param>
            <param name="orientation">orientation for the whole queues output</param>
            <param name="color">starting color</param>
            <remarks><para>The render queue must contain only keys for already cached items!</para>
            <para>The color parameter serves as a global color definition. It may be overridem 
            by individual color specifications of the queue items.</para>
            </remarks>
        </member>
        <member name="E:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.CacheCleared">
            <summary>
            (IILTextRenderer) Event firing if the texture storage has been cleared 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLLineRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Resources.Markers">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Markers.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Markers.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            construct new legend object
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.Create(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            Create new instance of ILLegend, depending on graphics device type
            </summary>
            <param name="panel">panel hosting this legend</param>
            <returns>newly created ILLegend object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.Draw(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle)">
            <summary>
            Draw the legend onto a predefined bitmap or into GL context
            </summary>
            <param name="p">render properties</param>
            <param name="area">rectangle area defines region to draw legend contents into.</param>
            <remarks>This function does only render to a predefined bitmap, which must be given in p. Rendering to 
            (dvice dependent) graphic contexts is done in derived implementations.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Visible">
            <summary>
            get / set visibility for legend
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Opacity">
            <summary>
            Get/ set opacity for filled area, values: 0...1.0
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.BackgroundColor">
            <summary>
            Get / set background color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Location">
            <summary>
            get/ set location of legend box (upper/left corner, fraction of ClientSize [(0,0)...(1f,1F)]), empty for auto mode
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Size">
            <summary>
            get/ set size of legend box, empty for auto mode
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Border">
            <summary>
            set properties of legend's border 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLLegend.Draw(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle)">
            <summary>
            draw legend into opengl context
            </summary>
            <param name="p">rendering properties</param>
            <param name="area">area to draw the content into, if g is null, this will be ignored also</param>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILSubfigure">
            <summary>
            Plot control, provides ILPanel, colorbar and title
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILSubfigure.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Draws content of this subfigure into proedefined bitmap
            </summary>
            <param name="bitmap">predefined bitmap to draw content into. The size must have been initialized according to 'bounds'.</param>
            <param name="bounds">Rectangle specifying the region to be copied.</param>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILSubfigure.Panel">
            <summary>
            Gives access to the panel of the figure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILSubfigure.ColorBar">
            <summary>
            Gives access to the colorbar of the figure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILSubfigure.Title">
            <summary>
            Gives the title control
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSurfaceGraph">
            <summary>
            Surface graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILFilledGraph">
            <summary>
            Class representing abstract implementation of filled graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.Drawing.ILClippingData)">
            <summary>
            construct new filled graph
            </summary>
            <param name="panel">panel hosting the graph</param>
            <param name="X">X coords, if null, range 0..[cols of Z] will be created</param>
            <param name="Y">Y coords, if null, range 0..[rows of Z] will be created</param>
            <param name="Z">Z coords (heights)</param>
            <param name="C">Colors for Z</param>
            <param name="clippingContainer">gloabal limits of panel</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.CreateIndices">
            <summary>
            Create indices for filled graphs
            </summary>
            <remarks>Indices will be ordered to assemble individual triangles.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.checkVertexIndicesLength(System.Int32,System.Int32)">
            <summary>
            checks the length of index vector and allocate more memory if needed
            </summary>
            <param name="vertStrCount">Number of stripes to be drawn</param>
            <param name="vertStrLen">Number of indices for each stripe</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.checkGridIndicesLength(System.Int32,System.Int32)">
            <summary>
            checks the length of grid index vector and allocate more if needed
            </summary>
            <param name="gridStrCount">Number of stripes to be drawn</param>
            <param name="gridStrLen">Number of indices for each stripe</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.Dispose">
            <summary>
            Dispose off this filled graph (grid-)indices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.Configure">
            <summary>
            checks &amp; if neccessary triggers recreation of all vertices and indices
            </summary>
            <remarks>This function is called by the enclosing panel, f.e. when rotation
            occours, which makes a reconfiguration neccessary. It internally calls CreateVertices() 
            and CreateIndices().</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Wireframe">
            <summary>
            Wireframe line properties
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Opacity">
            <summary>
            Get / set the transparency for the graph (percent)
            </summary>
            <remarks>1.0f (opaque) ... 0.0f (transparent)</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Filled">
            <summary>
            Determine, if the tiles (rectangle areas between data points) 
            constructing the surface will be filled or invisible
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Data">
            <summary>
             get a reference to the internal data array
            </summary>
            <remarks>modifications to the array returned will 
            <b>not</b> alter the data the graph is based on.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSurfaceGraph.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.Drawing.ILClippingData)">
            <summary>
            construct new surface graph, provide all 3 coordinates
            </summary>
            <param name="panel">panel this graph is to be hosted in</param>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
            <param name="C">Color values</param>
            <param name="clippingContainer"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSurfaceGraph.CreateIndices">
            <summary>
            create indices for ILSurfaceGraph triangles 
            </summary>
            <remarks>If possible, the indices will assemble triangle strips. If not -
            the base implementation will be used to create individual triangles.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSurfaceGraph.Shading">
            <summary>
            determine, how the color for surface tiles will be drawn
            </summary>
            <remarks>Interpolated will interpolate the color for the 
            tiles between all corner data points. Flat will draw the area of the 
            tile in a single color. The color than reflects the average value of 
            all corner data points.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage">
            <summary>
            OpenGL implementation of ILTextureStorage
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.MakeCurrent">
            <summary>
            Select this storage to be current in GL
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="bmp">new item bitmap data, ARGB format</param>
            <param name="bmpRectF">rectangle used in bitmap</param>
            <param name="rect">rectangle specifying area to store the data into the texture sheet, 
            integer pixels coords: range from 0...m_width|m_height (i.e. '512' f.e.)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.Dispose(System.Boolean)">
            <summary>
            dispose off the texture storage's ressources
            </summary>
            <param name="manual"></param>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf">
            <summary>
            a scene graph node, holding a single shape
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create a new shaped leaf
            </summary>
            <param name="panel"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Invalidate">
            <summary>
            invalidate this and all nodes up to root
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Invalidate(System.Boolean)">
            <summary>
            invalidate this node and all nodes up to root
            </summary>
            <param name="invalidateShape">true: invalidate the shape also</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draw this shape contained in this node (internal use)  
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Shape">
            <summary>
            Get / set the shape of the scene graph node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.PositionMin">
            <summary>
            the minimum position of contained shape 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.PositionMax">
            <summary>
            the maximum position of contained shape 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Center">
            <summary>
            the computed center of contained shape 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create triangles, for delayed vertex definition
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertices must be filled 
            with data manually afterwards.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create triangles 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create triangles, indexed storage
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="mapping">Mapping of shapes, composes triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,System.Drawing.Color,ILNumerics.ILBaseArray)">
            <summary>
            create triangles, flat shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="color">Fill color for all shapes.</param>
            <param name="mapping">Mapping of shapes, composes lit triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single lit triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lit triangles, interpolated shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32,System.Int32)">
            <summary>
            create light composite shape
            </summary>
            <param name="panel">scene hosting the scene</param>
            <param name="numVertices">number of overall vertices for the shape</param>
            <param name="verticesPerShape">Number of vertices per shape</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.Computation.CreateShapeIndicesIndex(ILNumerics.ILArray{System.Int32})">
            <summary>
            Creates the index of the shape indices.
            </summary>
            <param name="shapeIndices">The shape indices.</param>
            <returns>index of shape indices</returns>
            <remarks>The index of shape indices is used for fast facette lookup while (auto) creating
            the normal vectors for the vertices. Therefore, the index of every vertex used in the shape
            serves as index for a list of those facettes, where that vertex occures.
            <para>TODO: may be replaced by a custom data structure in order to decrease memory requirements?</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.Computation.CalculateNormals(`0[],ILNumerics.ILArray{System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Calculates the normals.
            </summary>
            <param name="vertices">vertex array of the shape</param>
            <param name="shapeIndices">The shape mapping indices.</param>
            <param name="shapeIndicesIndex">Index of the shape indices.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.ILPoint3Df,System.Single,System.Drawing.Color)">
            <summary>
            create new lit sphere, resolution of 3 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="center">center position</param>
            <param name="radius">radius of the sphere</param>
            <param name="color">color of the sphere</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.ILPoint3Df,System.Single,System.Drawing.Color,System.Int32)">
            <summary>
            create new lit sphere for a scene graph
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="center">center position</param>
            <param name="radius">radius of the sphere</param>
            <param name="color">color of the sphere</param>
            <param name="detail">number of triangularization iterations, typical: 0..4</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.Triangularize(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Int32},System.Int32,ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Int32}@)">
            <summary>
            increase the number of triangles by doubling existing triangles
            </summary>
            <param name="vertices">vertices</param>
            <param name="triangles">triangle index definitions</param>
            <param name="iterations">number of iterations. On each iteration, 4 triangles will replace every single triangle!</param>
            <param name="outVertices">The out vertices.</param>
            <param name="outTriangles">The out triangles.</param>
            <remarks><para>Incoming triangles are expected not to be degenerated. This means:
            Every edge is used only twice at most. No triangle shares more than 2
            corners with some other triangle. </para>
            	<para>Incoming arrays will not be altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.CreateVertices(ILNumerics.Drawing.ILPoint3Df,System.Single,System.Int32,System.Int32,ILNumerics.ILArray{System.Int32}@)">
            <summary>
            create vertex data [unevenly distributed, depricated]
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="horRes"></param>
            <param name="vertRes"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.CreateVerticesTri(System.Int32,ILNumerics.ILArray{System.Int32}@)">
            <summary>
            create vertices by triangularization, starting from icosahedron and subseq. creating finer grained details
            </summary>
            <param name="detail">number of iterations for triangularization</param>
            <param name="indices">out param: return triangles</param>
            <returns>vertex data</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitSurface">
            <summary>
            surface plot supporting light and transparency
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            create new lit surface, provide data heights (Z values)
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="Z">data matrix, at least 2 rows, 2 columns</param>
            <param name="colormap">colormap used for auto coloring the surface</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            create new lit surface, provide data for X,Y and Z coordinates
            </summary>
            <param name="panel">the panel hosting the scene</param>
            <param name="X">X coordinates matrix, same size as Z or null</param>
            <param name="Y">Y coordinates matrix, same size as Z or null</param>
            <param name="Z">Z data matrix, at least 2 rows, 2 columns</param>
            <param name="colormap">colormap used for auto coloring the surface</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray)">
            <summary>
            create new lit surface, provide heights (Z values)
            </summary>
            <param name="panel">the panel hosting the scene</param>
            <param name="Z">data matrix, at least 2 rows, 2 columns</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.Configure">
            <summary>
            (re)configure the plot, causes a recreation of all quads due to changed parameters
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Opacity">
            <summary>
            Overall opacity for the surface 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Colormap">
            <summary>
            colormap used for coloring the surface 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Label">
            <summary>
            reference to the label for the surface
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.XValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.YValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.ZValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Data">
            <summary>
            [deprecated] Z coordinate values, use ZValues instead!
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Quads">
            <summary>
            get reference to IILLitQuads lit composite shape used for rendering the surface
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layoutData">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the axis 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Marker.ILMarker">
            <summary>
            Properties for marker (f.e. used for line plots)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILMarker.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create a new marker property instance
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Marker.ILMarker.Changed">
            <summary>
            Fires when the properties have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Visible">
            <summary>
            Switch on or off the visibility of all markers 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Color">
            <summary>
            Marker color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Shape">
            <summary>
            Shape of markers, compatible with string, markerStyle or bitmap arguments
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Size">
            <summary>
            Size of markers in pixels (default: 10)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickProvider">
            <summary>
            tick provider function delegate definition
            </summary>
            <param name="min">minimum axis limit</param>
            <param name="max">maximum axis limit</param>
            <param name="maxCount">maximum number of ticks to create</param>
            <returns>list of tick position to be drawn</returns>
            <remarks>User defined tick providers must fulfill this delegates signature. 
            </remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILClippingDataChangedEvent">
            <summary>
            occours if the clipping data for an subfigure have changed
            </summary>
            <param name="sender">object which changed the data</param>
            <param name="e">arguments containing the new clipping data</param>
        </member>
        <member name="T:ILNumerics.Drawing.MeasureTextDelegate">
            <summary>
            delegate used to measure text, device dependent
            </summary>
            <param name="text">text to be measured</param>
            <param name="font">Font used for rendering</param>
            <returns>Size in screen coords</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ClippingChangedEventArgs">
            <summary>
            arguments on ClippinChangedEvents
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ClippingChangedEventArgs.#ctor(ILNumerics.Drawing.ILClippingData)">
            <summary>
            creates a new ClippingChangedEventArgs object
            </summary>
            <param name="clippingData"></param>
        </member>
        <member name="F:ILNumerics.Drawing.ClippingChangedEventArgs.ClippingData">
            <summary>
            the current (new) clipping data
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceResetEvent">
            <summary>
            occours if a graphics device has been reset by the underlying graphics framework
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceCreatedEvent">
            <summary>
            occours if a graphics device has been (re)created by an output panel
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphChangedEventArgs">
            <summary>
            arguments to communicate changes on graphs 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILGraphChangedEventArgs.Source">
            <summary>
            string description of the changed parameter
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphChangedEvent">
            <summary>
            fires, if properties of a graph were /have changed
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs">
            <summary>
            arguments for ILGraphCollectionChanged events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs.Configurator">
            <summary>
            description of element changed (in some cases)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs.#ctor(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.GraphCollectionChangeReason,ILNumerics.Drawing.Interfaces.IILPanelConfigurator)">
            <summary>
            arguments for GraphCollectionChanged events
            </summary>
            <param name="graph">the graph who was changed, for ILPlot: the scene graph</param>
            <param name="reason">reason</param>
            <param name="configurator"> instance of IILPanelConfigurator or null</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphCollectionChangedEvent">
            <summary>
            occurs on changes to the graph collection: add, delete
            </summary>
            <param name="sender">graph collection</param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickAddingArgs">
            <summary>
            Event handler handling LabeledTickAdding events 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LabeledTickAddingHandler">
            <summary>
            Delegate definition for function handling LabeledTickAdding events
            </summary>
            <param name="sender">the sender of the event (f.e. ILTickCollection)</param>
            <param name="args">arguments </param>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxisChangedEventArgs">
            <summary>
            Event arguments for axis changed events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILAxisChangedEventArgs.AxisName">
            <summary>
            Name of changed axis (X-,Y-,ZAxis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxisChangedEventArgs.#ctor(ILNumerics.Drawing.AxisNames)">
            <summary>
            construct a new instance 
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:ILNumerics.Drawing.AxisChangedEventHandler">
            <summary>
            delegate for functions handling AxisChanged events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILSceneGraphNodeEventArgs">
            <summary>
            event argument for SceneGraphNodeAdded events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILSceneGraphNodeEventArgs.Node">
            <summary>
            Node which was added to the scene graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.SceneGraphNodeHandler">
            <summary>
            used for events fired once a SceneGraphNode was added
            </summary>
            <param name="sender"></param>
            <param name="?"></param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILHashCreator">
            <summary>
            Helper class used to create hashes for renderable items (currently text only)
            </summary>
            <remarks>This class should be used to retrieve an (unique) key for any 
            renderable items used in ILNumerics.Drawing renderer classes. This way on can 
            ensure not to create hash conflicts between different cached items.
             </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.Drawing.Labeling.ILHashCreator.Hash(System.Drawing.Font,System.String)" -->
        <member name="M:ILNumerics.Drawing.Labeling.ILHashCreator.Hash(System.Drawing.Bitmap)">
            <summary>
            create unique hash for bitmaps
            </summary>
            <param name="bitmap">bitmap</param>
            <returns>unique key identifying the bitmap</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILQuad">
            <summary>
            A single simple bordered quad
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create composite shape, consisting out of lit quads 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices needed for all lit quads</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create composite shape, consisting out of lit quads 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector</param>
            <param name="Y">y coordinates vector</param>
            <param name="Z">z coordinates vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create composite shape, consisting out of lit quads 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector</param>
            <param name="Y">y coordinates vector</param>
            <param name="Z">z coordinates vector</param>
            <param name="mapping">Mapping of shapes, composes quads out of vertices. Matrix having 4 rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may get used arbitrary 
            times (or not at all). All elements must be positive integer values in range 
            0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,System.Drawing.Color,ILNumerics.ILBaseArray)">
            <summary>
            create lit quads, flat shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates (true world coords), vector with [vertCount] values</param>
            <param name="Y">y coordinates (true world coords), vector with [vertCount] values</param>
            <param name="Z">z coordinates (true world coords), vector with [vertCount] values</param>
            <param name="color">Color to fill all quads with.</param>
            <param name="mapping">Mapping of shapes, composes quads out of vertices. Matrix having 4 rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may get used arbitrary 
            times (or not at all). All elements must be positive integer values in range 
            0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lit quads, interpolated shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates (true world coords), vector with [vertCount] values</param>
            <param name="Y">y coordinates (true world coords), vector with [vertCount] values</param>
            <param name="Z">z coordinates (true world coords), vector with [vertCount] values</param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes quads out of vertices. Matrix having 4 rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may get used arbitrary 
            times (or not at all). All elements must be positive integer values in range 
            0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLLinesRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILImageSCGraph">
            <summary>
            class rendering plain color-coded area graphs
            </summary>
            <remarks>This class derives from ILFilledGraph and adds a ZPosition property.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILImageSCGraph.ZPosition">
            <summary>
            Z position for ImageSC graph (default: -Inf)
            </summary>
            <remarks>The position of the ImageSC plane is specified by a Z coordinate.
            The coordinate can set to the following values: 
            <list type="bullet">
            <item>any single precision value, will position the plane on that specific value</item>
            <item><i>negative infinity</i>, will position the plane on the bottom of the viewing cube</item>
            <item><i>positive infinity</i>, position the plane on top of the unit cube.</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILStyledMarkerShape.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.MarkerStyle)">
            <summary>
            create new styled marker
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILStyledMarkerShape.BitmapFromStyle(ILNumerics.Drawing.MarkerStyle)">
            <summary>
            convert marker style into bitmap
            </summary>
            <param name="marker">marker with style property</param>
            <returns>bitmap according to style</returns>
            <remarks>the bitmap will be loaded from ILNumerics.Drawing ressources. For marker style 'bitmap'
            the bitmap referenced in the marker will be returned.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILStyledMarkerShape.Style">
            <summary>
            The style of markers 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILControl">
            <summary>
            Main ILNumerics.Net figure control - capable of displaying multiple subfigures.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILControl.#ctor">
            <summary>
            create new figure control
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILControl.Tile(System.Int32,System.Int32,System.Int32)">
            <summary>
            Tile this figure control to display mltiple subfigures in rows and columns
            </summary>
            <param name="rows">number of rows </param>
            <param name="columns">number of columns</param>
            <param name="current">the index of the subfigure to be set as active subfigure. (sequential index)</param>
            <returns>newly selected active subfigure</returns>
            <remarks>existing subfigures will remain in the figure control - if possible. If the number of subfigures requested (rows * columns) is larger than the number of subfigures existing, new subfigures will be created. </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Controls.ILControl.components">
            <summary> 
            Erforderliche Designervariable.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILControl.Dispose(System.Boolean)">
            <summary> 
            Verwendete Ressourcen bereinigen.
            </summary>
            <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILControl.InitializeComponent">
            <summary> 
            Erforderliche Methode für die Designerunterstützung. 
            Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILControl.Subfigure">
            <summary>
            Get / set active subfigure
            </summary>
            <value>the ILSubfigure value to be the newly active subfigure</value>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILControl.Subfigures">
            <summary>
            Get the subfigures as subfigure collection (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILControl.Item(System.Int32)">
            <summary>
            query a subfigure and set result as active subfigure
            </summary>
            <param name="key">the key of the subfigure</param>
            <returns>the subfigure</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILControl.Item(System.Int32,System.Int32)">
            <summary>
            Get subfigure by row and column and select as current subfigure
            </summary>
            <param name="row">location: row</param>
            <param name="col">location: column</param>
            <returns>subfigure on location specified. If row and/or column lay outside of bounds, 
            an exception will be thrown.</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRendererManager">
            <summary>
            Provides access to all (device dependent) ILRenderer available 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create manager instance, device dependent
            </summary>
            <param name="panel">the hosting panel, will give access to this manager instance</param>
            <remarks>While creating ILTextRendereManager instances, the executing assembly will be queried for 
            available classes matching the device. Corresponding types are than provided by calling the GetRenderer() method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Reflection.Assembly[])">
            <summary>
            create manager instance, device dependent
            </summary>
            <param name="panel">The hosting panel, giving access to his manager instance</param>
            <param name="assemblies">assemblies to query for matching ILRenderer types</param>
            <remarks>While creating ILRendererManager instances, the given assemblies will be queried for 
            available classes matching the device. Corresponding types are than provided by calling the 
            GetRenderer() method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.CreateInstance(System.String,System.Reflection.Assembly)">
            <summary>
            Create a new ILRenderer instance, matching the current graphics device
            </summary>
            <param name="typeName">full class name of the new text renderer</param>
            <param name="assembly">assembly hosting the textrenderer, null for executing assembly</param>
            <returns>newly created ILRenderer instance from assembly</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.GetDefault(ILNumerics.Drawing.CoordSystem)">
            <summary>
            Create the default instance of IILTextRenderer for 
            the current graphics device and a coord system
            </summary>
            <param name="coords">coord system, the renderer is 
            specialized and the default renderer for</param>
            <returns>default IILTextRenderer object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.queryAddRenderer(System.Type)">
            <summary>
            iterate over types attribute, select IILTextRenderer attribute, 
            register for later reference, add/overwrite default renderers
            </summary>
            <param name="t">IILTextRenderer type</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRendererManager.RendererNames">
            <summary>
            Get a collection of all IILTextRenderer types and corresponding displayNames available
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILTexMarkerShape.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.Marker.ILMarker,ILNumerics.Drawing.Shapes.C4bV3f[],System.Int32,System.Int32)">
            <summary>
            draw all markers (graph / legend)
            </summary>
            <param name="marker">the marker object (for properties)</param>
            <param name="vertices">coords, interleaved</param>
            <param name="vertcount">number of coords, special: -1 for legend rendering</param>
            <remarks>This function is reused for both: drawing in world coords (graph) and drawing in
            screen coords (legend). Latter case requires vertcount to be -1, vertices must contain
            at least 2 float values than!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.Interpreter">
            <summary>
            Interpreter instance usedt to convert expression into visual output
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.MaxLabelsDrawn">
            <summary>
            maximum number of labels to be drawn
            </summary>
            <remarks>If the graph contains more datapoints, only <i>MaxLabelsDrawn</i> markers 
            will be shown. This is for performance reasons only. Default is 50.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.ValueFormat">
            <summary>
            Format string used to convert value numbers into string 
            </summary>
            <remarks>Default: 'f'</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.Expression">
            <summary>
            Expression defining the marker tex shape
            </summary>
            <remarks>The expression may uses markups interpretable by the current interpreter. This is - by default - an simple Tex interpreter. 
            In addition to all partial tex commands, one may uses placeholders '\\index', '\\xvalue' and/or '\\yvalue'. Those placeholders will be 
            replaces for every marker individually with its real values at runtime.
            <para>This property is readonly. In order to change the expression, assign the new expression string to the Shape property of the 
            containing ILMarker class.</para></remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitPolygon">
            <summary>
            A simple lit polygon, rendering arbitrary number of corners, bordered, supports light
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitPolygon.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update vertices, may also alter number of edges 
            </summary>
            <param name="X">X coordinates</param>                   
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureData">
            <summary>
            class encapsulating texture item definitions
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.TextureRectangle">
            <summary>
            the item's rectangle area in the texture sheet (texture coordinates) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.Width">
            <summary>
            Width of the (rendered) item
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.Height">
            <summary>
            Height of the (rendered) item
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILMovingDockPanel">
            <summary>
            Label with flexible configurable orientation of it's text 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILMovingDockPanel.BackgroundGradientStrength">
            <summary>
            Intensity of lighting / darkner effect for background color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILMovingDockPanel.BackgroundGradientDeg">
            <summary>
            orientation for background gradient effect
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILMovingDockPanel.Orientation">
            <summary>
            set the orientation of text (Horizontal/Vertical)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILMovingDockPanel.StandardOrientation">
            <summary>
            The type of orientation (hor./ vert) if the control is not docked
            </summary>
            <remarks>Setting this value will not alter the way the display is
            currently drawn until the control returns from a docked state the next time.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILMovingDockPanel.IsMoving">
            <summary>
            True, if the control is currently moved around by the user
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILColorBar.RegisterRangeSource(ILNumerics.Drawing.ILClippingData)">
            <summary>
            register clipping range object as source for range and its changes
            </summary>
            <param name="clipping">clipping data object</param>
            <returns>true, if the source was registered successfully</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILColorBar.Update(System.Single,System.Single,ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            update range for color bar, supply color provider
            </summary>
            <param name="minValue">min value</param>
            <param name="maxValue">max value</param>
            <param name="colorProvider">color provider (not implemented)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILColorBar.Update(System.Single,System.Single)">
            <summary>
            update data range for the color bar
            </summary>
            <param name="minValue">min value</param>
            <param name="maxValue">max value</param>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILColorBar.Colormap">
            <summary>
            Colormap used to translate colors indices
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILColorBar.TickLabelsPadding">
            <summary>
            padding (in pixels) between the tick labels 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILColorBar.Precision">
            <summary>
            Number of digits to be displayed for values 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILColorBar.MinValue">
            <summary>
            get / set minimum value for the values range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILColorBar.MaxValue">
            <summary>
            get / set maximum value for the values range
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILCreationFactory">
            <summary>
            interface for a painter factory, capable of creating device dependend axes and graphs 
            </summary>
            <remarks>The interface is implemented by (device dependent) panel implementations. 
            It is used to create the ILPanel's object hirarchy on startup. </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateAxis(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,System.Object[])">
            <summary>
            create an axis according to the current 
            </summary>
            <param name="name">axis name</param>
            <param name="clippingView">clipping of the host</param>
            <param name="parameters">additional parameters</param>
            <returns>newly created axis object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateGraph(ILNumerics.ILBaseArray,ILNumerics.Drawing.GraphType,System.Object[])">
            <summary>
            Create a new specific ILGraph object (device dependent)
            </summary>
            <param name="data">numeric data for the new graph</param>
            <param name="graphType">type of graph</param>
            <param name="additionalParams">additional parameter</param>
            <returns>newly created graph instance</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateSceneGraph">
            <summary>
            create a new device dependant scene graph for hosting ILPrimitives
            </summary>
            <returns>scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateVertexRenderer(System.Type,ILNumerics.Drawing.Shapes.ILShape)">
            <summary>
            create vertex renderer for rendering arbitrary vertices. 
            </summary>
            <param name="type">underlying vertex type (value type)</param>
            <returns>vertex renderer</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLVertexRendererC4fN3fV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4fN3fV3f (for lit shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph">
            <summary>
            OpenGL implementation for ILSurfaceGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Dispose">
            <summary>
            Dispose off this graph's vertices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draw the graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Invalidate">
            <summary>
            Ensures the recreation of the graph if neccessary
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.VertexC4N3V3">
            <summary>
            Vertex definition: 4Color, 3Normal, 3 Vertex - all float
            </summary>
            <remarks>CAUTION! The vertex is not usable with OpenGL via vartex arrays this way!
            We had to recognize sporadic crashs when drawing this way! Todo: ... to be investigated.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILClippingData">
            <summary>
            Class holding and managing limits for a 3 dimensional cube
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.OnChange">
            <summary>
            called if the limits have changed
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingSuspend">
            <summary>
            suspend the firing of events until EventingResume has been called
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingResume">
            <summary>
            Resume previously suspended eventing. Start sending events again.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingStart">
            <summary>
            enable eventing without sending pending events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILClippingData)">
            <summary>
            update ranges for this object with union of both ranges. 
            </summary>
            <param name="clipData">clipping ranges to create union with</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILPoint3Df,System.Int32)">
            <summary>
            update ranges for this object with point coords for specific axes
            </summary>
            <param name="point">point with coords to update ranges with</param>
            <param name="updateBitFlags">bitflag combination to specify axis to be recognized: 1,2,4 -> x,y,z</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            update clipping data for this object with union of this and rectangle specified
            </summary>
            <param name="luCorner">left upper corner</param>
            <param name="rbCorner">right lower corner</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Set(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Set clipping limits to volume inside the box specified 
            </summary>
            <param name="lunCorner">left-upper-near corner of the volume box</param>
            <param name="rbfCorner">right-bottom-far corner of the volume box</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Reset">
            <summary>
            reset this clipping range to initial (all empty)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.CopyFrom(ILNumerics.Drawing.ILClippingData)">
            <summary>
            copy this from other clipping data
            </summary>
            <param name="m_clippingData"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.ScaleToUnitCube">
            <summary>
            stretch clipping region to unit cube [0 1][0 1][0 1] 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.CenterToUnitCube">
            <summary>
            offset centering scaled unit cube to zero: [-0.5 0.5][-0.5 0.5][-0.5 0.5]
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Clone">
            <summary>
            Clone this instance and return clone
            </summary>
            <returns>clone</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Map(System.Single,System.Single,System.Single)">
            <summary>
            Map coordinat from unit cube space [-0.5..0.5] into the space limited by this clipping data
            </summary>
            <param name="x">x coordinate (unit cube space: -0.5 ... 0.5)</param>
            <param name="y">y coordinate (unit cube space: -0.5 ... 0.5)</param>
            <param name="z">z coordinate (unit cube space: -0.5 ... 0.5)</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.GetZoomParameter(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Single,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            Expand/shrink all those edges, not touched by the given line
            </summary>
            <param name="nearLineEnd">near line point</param>
            <param name="farLineEnd">far line point</param>
            <param name="offset">multiplicator, shrink-/expand value</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EnsureValidSize">
            <summary>
            Ensure that this clipping data has valid length for all dimensions  [deprecated]
            </summary>
            <remarks>If the length of the clipping cube is infinity for any dimension, 
            that dimension is set to a range of -0.5...0.5.
            <para>This function is to be called by custom graphs which create their 
            size <b>relative</b> to the size of the clipping container. Those 
            graphs will need a valid container size and may call this function in the 
            constructor.</para></remarks>
            <returns>true if the length in any dimension had to be corrected (set to 1.0), false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.op_Equality(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILClippingData)">
            <summary>
            Equalty operator overload, true if both cubes span the same region in 3D space 
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>true if both cubes span the same 3D space, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.op_Inequality(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILClippingData)">
            <summary>
            unequalty operator
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>false if both cubes span the same 3D space, true otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.GetHashCode">
            <summary>
            Returns hash code for this ILClippingData
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Equals(System.Object)">
            <summary>
            Compares to cube objects
            </summary>
            <param name="obj"></param>
            <returns>true if obj references this class instance, false otherwise</returns>
        </member>
        <member name="E:ILNumerics.Drawing.ILClippingData.Changed">
            <summary>
            fires if the data range have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.SphereRadius">
            <summary>
            the radius of a sphere tightly enclosing the box determined by this clipping data limits (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.XMin">
            <summary>
            minimum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.YMin">
            <summary>
            minimum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.ZMin">
            <summary>
            minimum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.XMax">
            <summary>
            maximum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.YMax">
            <summary>
            maximum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.ZMax">
            <summary>
            maximum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.Min">
            <summary>
            minimum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.Max">
            <summary>
            maximum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.CenterF">
            <summary>
            get center of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.WidthF">
            <summary>
            get width (x-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.HeightF">
            <summary>
            get height (y-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.DepthF">
            <summary>
            get depth (z-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.IsDirty">
            <summary>
            marks the limits as altered, without having fired a changed event yet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.AllowZeroVolume">
            <summary>
            true: this clipping data always ensures a non-zero volume
            </summary>
            <remarks>'NonZeroVolumne' means, non of Depth,Width nor Heigth are allowed to be zero. If some edge of the cube is set to zero, the class expands this edge by 1 in each direction.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILTriangle">
            <summary>
            A simple bordered triangle
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create quads, for delayed vertex definition
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertices must be filled 
            with data manually afterwards.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create quads, define vertex positions 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create quads, indexed storage
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="mapping">Mapping of shapes, composes quads out of vertices. Matrix having  
            4 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,System.Drawing.Color,ILNumerics.ILBaseArray)">
            <summary>
            create quads, flat shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="color">Fill color for all shapes.</param>
            <param name="mapping">Composes shapes out of given vertices. Matrix having 4 rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z. 
            The 4 elements in a column therefore compose a single quad. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[vertCount-1].</param>
            <param name="mapping">Mapping composes quads out of vertices. Matrix having  
            4 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create quads, interpolated shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes quads out of vertices. Matrix having  
            4 rows. Every element in a column references a vertex according to its position index in vectors X,Y,Z.
            The 4 elements in a column therefore compose a single quad. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILPolygon">
            <summary>
            A simple polygon, rendering arbitrary number of corners, bordered
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILPolygon.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update vertices, may also alter number of edges 
            </summary>
            <param name="X">X coordinates</param>                   
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLines.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            Create new lines composite shapes, prepare memory for vertices only
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of overall vertices in the shape</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLines.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create new lines composite shape
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLines.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create new lines composite shape
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="X">X coords vector</param>
            <param name="Y">Y coords vector</param>
            <param name="Z">Z coords vector</param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having  
            2 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 2 elements in a column therefore compose a single line. Vertices may get used arbitrary times 
            (or not at all). All elements must be positive integer values in range 
            0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLines.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lines composite shape 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having  
            2 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 2 elements in a column therefore compose a single line. Vertices may get used arbitrary times 
            (or not at all). All elements must be positive integer values in range 
            0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Properties">
            <summary>
            all properties for the lines (in shading mode 'flat')
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Antialiasing">
            <summary>
            determines, if the line is to be drawn antialiased (on width > 1 only)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Pattern">
            <summary>
            stipple pattern for the line, if Style is set to custom pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.PatternScale">
            <summary>
            scaling for the stipple pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Style">
            <summary>
            line style, default: solid
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Width">
            <summary>
            line width (pixels)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.FillColor">
            <summary>
            color for the lines (in shading mode 'flat')
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLine">
            <summary>
            A simple single line
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create new simple line with 2 ends
            </summary>
            <param name="panel"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create new line, determine number of vertices
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of vertices for the line</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create new line, give vertices positions also
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.Update(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            update vertices, may also alter number of line segments 
            </summary>
            <param name="X">X coordinates</param>                   
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Properties">
            <summary>
            [deprecated] line properties, use individual properties of ILLine instead
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.OldestVertexID">
            <summary>
            the oldest vertex to be removed on the next Queue() call
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Antialiasing">
            <summary>
            determines, if the line is to be drawn antialiased (on width > 1 only)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Pattern">
            <summary>
            stipple pattern for the line, if Style is set to custom pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.PatternScale">
            <summary>
            scaling for the stipple pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Style">
            <summary>
            line style, default: solid
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Width">
            <summary>
            line width (pixels)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.FillColor">
            <summary>
            inner color of the line
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILBarGraph2D">
            <summary>
            simple updatable bar graph implementation, fixed number of bars, simple example implementation derived from ILSceneGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph2D.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray)">
            <summary>
            create new 2D bar graph
            </summary>
            <param name="panel">hosting panel</param>
            <param name="data">numeric vector data, heights of bars</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph2D.Queue(System.Single)">
            <summary>
            add 'new' bar with new value and remove oldest bar
            </summary>
            <param name="value">height of new bar</param>
            <returns>discarded value</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.OpacityOldest">
            <summary>
            Sets the opacity for the 'oldest' bar. May be used as 'Fading-Out' effect. (Default: 255)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.BarWidth">
            <summary>
            padding between graphs 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.Count">
            <summary>
            number of bars in the graph
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.Item(System.Int32)">
            <summary>
            return reference to single bar (ILQuad) by index
            </summary>
            <param name="index">index of the bar</param>
            <returns>the bar shape as ILQuad</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ILCamera">
            <summary>
            This class represents the camera's positioning and aiming direction.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.OnChange">
            <summary>
            Fires a Changed event
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.Offset">
            <summary>
            Offset angle for 2nd cached triangular phi value (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosPhiShift">
            <summary>
            cachced triangular phi value with offset (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinPhiShift">
            <summary>
            cachced triangular phi value with offset (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosPhi">
            <summary>
            cached value for cosine of phi - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinPhi">
            <summary>
            cached value for sine of phi - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosRho">
            <summary>
            cached value for cosine of rho - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinRho">
            <summary>
            cached value for sine of rho - this is readonly and for performance only.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.#ctor">
            <summary>
            Create a viewport: view at scene from top, no rotation
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingSuspend">
            <summary>
            suspend the firing of events until EventingResume() was called
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingResume">
            <summary>
            Resume firing 'Change' events after it has been suspended
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingResume(System.Boolean)">
            <summary>
            Resume firing 'Change' events, optionally skip pending events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.Set(System.Single,System.Single,System.Single)">
            <summary>
            Set both angles and distance at once  
            </summary>
            <param name="phi">Rotation, radians</param>
            <param name="rho">Pitch, radians</param>
            <param name="distance">Distance from scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.SetDeg(System.Single,System.Single,System.Single)">
            <summary>
            Set complete camera position (angles and distance) at once
            </summary>
            <param name="phi">Rotation (degrees)</param>
            <param name="rho">Pitch (degrees)</param>
            <param name="distance">Distance from scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.ToString">
            <summary>
            Convert camera position to string
            </summary>
            <returns>string display with distance,roatation and pitch</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.updatePosition">
            <summary>
            update internal cartesian (absolut) coordinates of position relative 
            to lookAt point. To be called after any polar coordinates were changed.
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILCamera.Changed">
            <summary>
            fires, if the position of the camera has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LookAt">
            <summary>
            point, the camera is aiming at (world coords)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Distance">
            <summary>
            distance from the scene (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_phiDebugDisp">
            <summary>
            debugger helper: display phi in degrees (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_rhoDebugDisp">
            <summary>
            debugger helper: display rho in degrees
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Phi">
            <summary>
            rotation of the scene (seen from above) [radians, readlony, rel. to lookat]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Rho">
            <summary>
            pitch of the scene [radians], setting moves camera around lookat point
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Quadrant">
            <summary>
            Quadrant the camera is currently watching the scene from
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromTop">
            <summary>
            Determine, if camera is placed in an upper quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromLeft">
            <summary>
            Determine, if camera is located in an left quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromFront">
            <summary>
            Determine, if camera is located in an front quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Is2DView">
            <summary>
            true, when looking from top on the un-rotated scene (common for 2D plots)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Position">
            <summary>
            get/set camera position, absolute cartesian coordinates
            </summary>
            <remarks>Keep in mind, the angle for phi points towards negative Y axis! The cartesian property 
            <paramref name="Position"/> handles the camera position in absolute world coordinates, while the 
            polar coordinates (Rho, Phi, Distance) supress the camera position by means of coordinates 
            relative to the LookAt point (i.e. usually the center of the viewing cube)!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Top">
            <summary>
            orientation of the camera, readonly
            </summary>
            <remarks>This vector is readonly always points 'upwards'.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILPoints">
            <summary>
            points rendering shape, to be used in scene graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILPoints.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create new points 
            </summary>
            <param name="panel">panel hosting the scene graph</param>
            <param name="numPoints">number of points to create</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILPoints.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create point collection 
            </summary>
            <param name="panel">panel hosting the scene graph</param>
            <param name="data">numeric matrix with 1,2 or 3 rows, holding X,Y and Z values respectively</param>
            <param name="colors">3 rowed matrix with RGB values in columns. Values must lay in range 0...255. 
            If a 4th row is provided, it specifys the alpha value for the points (0...255). Otherwise the points will
            be fully opaque. </param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILPoints.Width">
            <summary>
            size (of all points)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPlot2DGraph">
            <summary>
            OpenGL implementation for ILPlot2DGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPlot2DGraph.Configure">
            <summary>
            (re)create vertex buffer, line-, texture objects
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILBarGraph3D">
            <summary>
            Simple 3D Bar Graph - plot
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray)">
            <summary>
            create a new 3D Bar Graph plot, provide data matrix
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="data">data matrix, at least 2x2 entries</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.SetLabels(ILNumerics.Drawing.Controls.ILPanel,System.String,System.String,System.String,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <summary>
            set axes labels and tick labels at once
            </summary>
            <param name="panel">panel hosting the plot</param>
            <param name="xlabel">label text for x axis</param>
            <param name="ylabel">label text for y axis</param>
            <param name="zlabel">label text for z axis</param>
            <param name="xtickLabels">collection of strings for columns labels (x-direction)</param>
            <param name="ytickLabels">collection of strings for row labels (x-direction)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.ConfigurePanel(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            configure default view of panel, called when adding the plot to the panel
            </summary>
            <param name="panel">panel hosting the plot</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph3D.Opacity">
            <summary>
            get/set opacity of the bars
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph3D.Item(System.Int32,System.Int32)">
            <summary>
            individual access to each bar (ILLitBox) 
            </summary>
            <param name="row">row index, 0 based</param>
            <param name="col">column index, 0 based</param>
            <returns>lit box shape at specified position</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLVertexRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph">
            <summary>
            OpenGL implementation for ILImageSCGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draws the graph into existing context
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Dispose">
            <summary>
            Dispose off this graph's vertices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Invalidate">
            <summary>
            Ensures the recalculation of vertices if neccessary
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.VertexC4V2">
            <summary>
            Vertex definition: 4Color (uint), 2 Vertex (float)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILLightCollection">
            <summary>
            collection of 8 lights, individual configurable
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILLightCollection.Enabled">
            <summary>
            set: enable/disable all lights; get: return true, if at least one light is enabled, false else 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILLightCollection.Item(System.Int32)">
            <summary>
            get light at specific index
            </summary>
            <param name="i">index of light, valid: 0...7</param>
            <returns>Light at index i</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Int32)">
            <summary>
            create lit triangles, for delayed vertex definition
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertices must be filled 
            with data manually afterwards.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lit triangles 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lit triangles, indexed storage
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="mapping">Mapping of shapes, composes lit triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single lit triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,System.Drawing.Color,ILNumerics.ILBaseArray)">
            <summary>
            create lit triangles, flat shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="color">Fill color for all shapes.</param>
            <param name="mapping">Mapping of shapes, composes lit triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single lit triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            create lit triangles, interpolated shading
            </summary>
            <param name="panel">hosting panel</param>
            <param name="X">x coordinates vector </param>
            <param name="Y">y coordinates vector </param>
            <param name="Z">z coordinates vector </param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <param name="mapping">Mapping of shapes, composes lit triangles out of vertices. Matrix having  
            3 rows. Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The 3 elements in a column therefore compose a single lit triangle. Vertices may 
            get used arbitrary times (or not at all). All elements must be positive integer values in 
            range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
        </member>
        <member name="T:ILNumerics.Drawing.Resources.Images">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Images.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Images.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitSink">
            <summary>
            ILNumerics.Drawing plot demonstration, supports multiple shapes, dynamic shape management, light and transparency
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.m_timer_Tick(System.Object,System.EventArgs)">
            <summary>
            timer tick event handler, called for updates of the interval timer
            </summary>
            <param name="sender">(not used) always this sink plot itself</param>
            <param name="e">(not used)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create new lit sink plot, assign default values 
            </summary>
            <param name="panel">panel hosting the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.#ctor(ILNumerics.Drawing.Controls.ILPanel,System.Single,System.Int32)">
            <summary>
            create new lit sink
            </summary>
            <param name="max">lenght of the squared ground</param>
            <param name="panel">panel hosting the scene</param>
            <param name="resolution">horizontal and vertical resolution</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.Configure">
            <summary>
            called once before rendering the frame, (re)configures the shapes after changes have been made to them
            </summary>
            <remarks><para>ILPlot plots can (not must) override this method. It is called, right before the scene is 
            rendered on screen. Since the containing shapes are independently configured, here (in ILPlot) we
            do only need to (re)configure those content of the plot, which must be recreated after changes have been 
            applied. In ILSink, f.e., changes to the sphere and the ground (ILLitSurface) are directly distributed 
            to the related shapes respectively. This happens, when calling any ILShape.Update() overload or after 
            ILShape.Invalidate() has been called. Those shapes will than reconfigure itself and must not be handled here. </para> 
            <para>In contrast to that, the (moving) grid lines of the sink plot are constantly created and removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.ConfigurePanel(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            configure the panel according to default settings of this plot
            </summary>
            <param name="panel">panel hosting the scene</param>
            <remarks>In order to force a custom configuration of the panel, 
            the plot implements the IILPanelConfigurator interface. For every plot 
            implementing this interface, the panel will be configured by this 
            function once the plot was added to the scene/ to the panel graphs collection.
            If the plot does not implement this interface, the panel settings will 
            not be altered.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Interval">
            <summary>
            get/ set the interval for updates of the moving grid lines [ms]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Opacity">
            <summary>
            Overall opacity for the ground 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Colormap">
            <summary>
            colormap used for coloring the ground
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Sphere">
            <summary>
            get reference to the lit sphere 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Ground">
            <summary>
            get reference to ILLitSurface (i.e. the ground)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.LinesPositionOffset">
            <summary>
            offset for the grid lines (for moving effect) 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.Computation.CreateMesh(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            create data needed to create the ground (ILLitSurface)
            </summary>
            <param name="Min">minimum (x and y)</param>
            <param name="Max">maximum (x and y)</param>
            <param name="cut">minimum sinkhole level</param>
            <param name="zNiveau">overall zero level</param>
            <param name="resol">horizontal and vertical resolution</param>
            <returns>list of X,Y and Z arrays</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.Drawing.Plots.ILLitSink.Computation.CreateLines(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single)" -->
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layout">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the axis 
            </summary>
            <param name="g">graphics object (ignored)</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILGraphComparer.Compare(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.Graphs.ILGraph)">
            <summary>
            sort graphs regarding their Z order 
            </summary>
            <param name="x">first graph</param>
            <param name="y">second graph</param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter">
            <summary>
            Simple, (partial) tex symbol interpreter 
            </summary>
            <remarks>this is the default interpreter for all ILLabelingElements</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.#ctor">
            <summary>
            create a new instance of a simple text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.matchSymbol(System.String,System.Int32@)">
            <summary>
            extract TextSymbol from text 
            </summary>
            <param name="text">text to extract symbol from</param>
            <param name="pos">current text character position</param>
            <returns>one of TextSymbol enumeration values</returns>
            <remarks>if one symbol was found, its enum representation is 
            returned and pos is increased by the corresponding number of 
            characters. If no matching symbol was found, pos is not altered 
            and TextSymbols.nothing will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TranslateSymbol(ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TextSymbols)">
            <summary>
             translates TextSymbol enum value to unicode character
            </summary>
            <param name="symbol">enum representation</param>
            <returns>unicode character</returns>
            <remarks>refers to: http://www.decodeunicode.org/ (f.e.)</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords">
            <summary>
            available keywords, interpretable by this IILInterpreter
            </summary>
            <remarks><para>The static instance ILSimpleTexInterpreter.Keywords can be 
            used to alter the keywords used to switch to different font styles etc.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Fontname">
            <summary>
            placeholder for font name control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Fontsize">
            <summary>
            placeholder for font size control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Italic">
            <summary>
            placeholder for italic font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Bold">
            <summary>
            placeholder for bold font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Color">
            <summary>
            placeholder for font color control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Reset">
            <summary>
            placeholder for text control sequence 'reset to initial value' 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TextSymbols">
            <summary>
            all available TextSymbols (like \\Alpha etc.) this IILTextInterpreter understands
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRenderQueue">
            <summary>
            the class collects renderable items which define 
            the graphical output for a render expression
            </summary>
            <remarks>ILRenderQueues are semi-immutable. Instances - once created - can only be cleared and 
            re-created, but not altered. Therefore, they keep the size of the output cached over their livetime.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueue.#ctor(System.String,System.Collections.Generic.List{ILNumerics.Drawing.Labeling.ILRenderQueueItem},System.Drawing.Size)">
            <summary>
             constructor, creates a new render queue with content
            </summary>
            <param name="expression">expression, which led to this queue</param>
            <param name="queue">prepared queue</param>
            <param name="size">size of content after rendering</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRenderQueue.Size">
            <summary>
            overall size of content of this render queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRenderQueue.Expression">
            <summary>
            Expression which led to this queue
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureManager">
            <summary>
             manages multiple texture sheets for storage and rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Clear">
            <summary>
            Clear all texture sheets and free their memory (cache) from GL. 
            </summary>
            <remarks> This will also fire the TextureCacheCleared event.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Reset">
            <summary>
            Reset any caching may beeing active for this texture manager. Call this once to begin rendering.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <returns>texture item data</returns>
            <remarks>If the key has been found in one of the texture sheets, the
            corresponding texture sheet will be set as current</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String,System.Boolean)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <param name="makeCurrent">if true: sets the corresponding texture sheet 
            as 'current' for subsequent rendering</param>
            <returns>texture item data</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String,System.Boolean,System.Int32@)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <param name="makeCurrent">if true: sets the corresponding texture sheet 
            as 'current' for subsequent rendering</param>
            <param name="textureID">returns the texture sheet key of the item, 
            used to identify the texture in the graphic system</param>
            <returns>texture item data</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.StoreTextureItem(System.String,System.Drawing.Bitmap)">
            <summary>
            Store item into texture cache, use full bitmap
            </summary>
            <param name="key">key used to identify the texture in cache</param>
            <param name="item">bitmap holding the texture content</param>
            <returns>true if the texture was successfully stored, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.StoreTextureItem(System.String,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Store item into texture cache, use full bitmap
            </summary>
            <param name="key">key used to identify the texture in cache</param>
            <param name="item">bitmap holding the texture content</param>
            <param name="rect">rectangle defining the area in item used for content</param>
            <returns>true if the texture was successfully stored, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Exists(System.String)">
            <summary>
            test, if a texture item for the given key exists 
            in any texture storage sheets
            </summary>
            <param name="key">unique key to be tested for</param>
            <returns>true, if a corresponding texture item exists, otherwise false</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Labeling.ILTextureManager.TextureCacheCleared">
            <summary>
            Fires, when the managed texture sheets are cleared. Registrars must rebuild needed items afterwards
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DeviceType">
            <summary>
            All texture sheets must conform to this graphics device
            </summary>
            <remarks>the graphics device type must be the same as 
            the one used by the panel!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DefaultHeight">
            <summary>
            Default height for new texture sheets
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DefaultWidth">
            <summary>
            Default width for new texture sheets
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILBorderFitLabel">
            <summary>
            Label with flexible configurable orientation of it's text 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILBorderFitLabel.Caption">
            <summary>
            The labels text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILBorderFitLabel.VerticalAlign">
            <summary>
            vertical alignment for the text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILBorderFitLabel.HorizontalAlign">
            <summary>
            horizontal alignment for the text
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPointsRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Lighting.ILMaterial.#ctor">
            <summary>
            construct new material object, initialize default values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Shininess">
            <summary>
            shape/intensity for specular reflection, range: 1...128
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Specular">
            <summary>
            color for specular reflection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Emission">
            <summary>
            color for emissive reflection
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILLabel">
            <summary>
            general label, mainly used for ILAxis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabel.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create a label for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabel.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Visible">
            <summary>
            get/set visibility for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Position">
            <summary>
            get/ set the position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Alignment">
            <summary>
            Alignment along the axis value range. Possible values: lower, center, upper
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Padding">
            <summary>
            Get/ set the padding used to seperate the label from the elements around it
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraph">
            <summary>
            The class implements a scene graph (tree), capable 
            of holding, managing and drawing all kinds of shapes.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.ILClippingData)">
            <summary>
            (internal) create new scene graph 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="clipping">clipping data object, usually member of the panel</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Is3DGraph">
            <summary>
            Determines if this graph renders in 3D, may overridden in derived class
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) draws the whole scene graph
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Configure">
            <summary>
            (internal use) configures and prepares the scene graph for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            add new node to root node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Shapes.ILShape)">
            <summary>
            add a shape to the root node
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Graphs.ILSceneGraphNode,ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode)">
            <summary>
            add new node as child of another node
            </summary>
            <param name="node"></param>
            <param name="parent"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.GetAllShapes">
            <summary>
            collect all shapes contained in any scene graph nodes
            </summary>
            <returns></returns>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraph.NodeAdded">
            <summary>
            fires, once somewhere in the graph a node was added
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraph.Root">
            <summary>
            root node of the scene graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRenderQueueItem">
            <summary>
            Single item with rendering instructions, used in ILRenderQueues
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Key">
            <summary>
            unique key, identifies the item in the render cache
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Offset">
            <summary>
            rendering offset for the item (used for sub-/superscripts etc.)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Color">
            <summary>
            individual color for the item 
            </summary>
            <remarks>If this property is set to Color.Empty, the item will 
            be drawn with the color assigned to hosting element.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueueItem.#ctor(System.String,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            construct a new ILRenderQueueItem
            </summary>
            <param name="key">unique key</param>
            <param name="xOffset">x coordinate for offset</param>
            <param name="yOffset">y coordinate for offset</param>
            <param name="color">individual color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueueItem.#ctor(System.String,System.Drawing.Point,System.Drawing.Color)">
            <summary>
            construct a new ILRenderQueueItem
            </summary>
            <param name="key">unique key</param>
            <param name="offset">offset</param>
            <param name="color">individual color</param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRendererAttribute">
            <summary>
            attribute used to identify IILTextRenderer types within assemblies 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.GraphicDeviceType">
            <summary>
            the type of graphic device, the renderer is able to handle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.Name">
            <summary>
            short name describing the renderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.NameLong">
            <summary>
            long name describing the renderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.IsDefault">
            <summary>
            determine, if this renderer should be used as default 
            renderer for the graphic device and the coord system
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.Coords">
            <summary>
            Detemine the coord system the renderer is based on
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererAttribute.#ctor(ILNumerics.Drawing.GraphicDeviceType,System.String,System.String)">
            <summary>
            Constructor for a new attribute describing non-default renderer
            </summary>
            <param name="type">graphic device type </param>
            <param name="Name">short name</param>
            <param name="NameLong">long name</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererAttribute.#ctor(ILNumerics.Drawing.GraphicDeviceType,System.String,System.String,System.Boolean,ILNumerics.Drawing.CoordSystem)">
            <summary>
            Constructor creating a new renderer attribute
            </summary>
            <param name="type">graphic device type </param>
            <param name="Name">short name</param>
            <param name="NameLong">long name</param>
            <param name="Default">'default' flag</param>
        </member>
        <member name="T:ILNumerics.Drawing.Internal.ILColorProvider">
            <summary>
            Color helper - change RGB to/ from HLS model
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Internal.ILColorProvider.H2RGB(System.Single)">
            <summary>
            convert hue value to RGB value, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Internal.ILColorProvider.H2RGB(System.Single,System.Single@,System.Single@,System.Single@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Internal.ILColorProvider.H2RGB(System.Single,System.Single[],System.Int32@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <param name="offset">offset into vertex array</param>
            <param name="va">vertex array, target for the color</param>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Internal.ILColorProvider.H2RGB(System.Single,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILGraphCollection">
            <summary>
            Collection of graph objects - all graphs currently contained in a subfigure
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.OnChange(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.GraphCollectionChangeReason,ILNumerics.Drawing.Interfaces.IILPanelConfigurator)">
            <summary>
            triggers the ILGraphCollectionChanged event
            </summary>
            <param name="sender"></param>
            <param name="reason"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.OnGraphChanged(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.ILGraphChangedEventArgs)">
            <summary>
            triggers GraphChanged event, bubbles from single graph
            </summary>
            <param name="graphArgs">event arguments from graph</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.#ctor(ILNumerics.Drawing.Interfaces.IILCreationFactory)">
            <summary>
            Create new ILGraphCollection
            </summary>
            <param name="panel">Output panel </param>
            <param name="clippingData"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Dispose">
            <summary>
            dispose all graphs contained in this collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Limits_Changed(System.Object,ILNumerics.Drawing.ClippingChangedEventArgs)">
            <summary>
            called once the limits of a graph have changed
            </summary>
            <param name="sender">graph</param>
            <param name="e">event args, holding a reference to the clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Clear">
            <summary>
            clear all graphs from the collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSurfGraph(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Add a new surface graph, provide all coordinate data
            </summary>
            <param name="Z">matrix holding Z coordinates (heights)</param>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSurfGraph(ILNumerics.ILBaseArray)">
            <summary>
            Add a new surface graph to collection
            </summary>
            <param name="data">matrix holding data to be plotted</param>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot(ILNumerics.Drawing.Plots.ILPlot)">
            <summary>
            add a plot to a new scene graph
            </summary> 
            <param name="plot">plot to be added to the panel</param>
            <returns>newly created scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSceneGraph">
            <summary>
            Add a new scene graph to collection
            </summary>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSceneGraph(ILNumerics.Drawing.Graphs.ILSceneGraph)">
            <summary>
            add an newly created scene graph instance to the collection of graphs 
            </summary>
            <param name="sceneGraph">exisisting instance of scene graph</param>
            <remarks><para>This overload may be used to add user defined graphs to 
            the collection of graphs in order to use them in ILPanels. The user 
            defined graph needs to derive from scene graph. It may uses all shapes 
            compatible with ILSceneGraph. (ILLine,ILPolygon,ILLitBox,ILQuads,ILTriangles, etc...)
            </para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddImageSCGraph(ILNumerics.ILBaseArray)">
            <summary>
            Add a new imagesc graph to collection
            </summary>
            <param name="data">matrix holding data to be drawn</param>
            <returns>newly created graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot2DGraph(ILNumerics.ILBaseArray)">
            <summary>
            Add new line graph(s) (2D) to collection
            </summary>
            <param name="data">vector/array with date to be plotted. For arrays, the columns will be used.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot2DGraph(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Add new X/Y 2D line graph(s), provide X and Y coordinates
            </summary>
            <param name="X">X coordinates. If this is a matrix, every column will produce an individual graph.</param>
            <param name="Y">Y coordinates. Same size than 'X'.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Add(ILNumerics.ILBaseArray,ILNumerics.Drawing.GraphType)">
            <summary>
            Add new numeric graph(s) of arbitrary (math) type
            </summary>
            <param name="data">data to be plotted</param>
            <param name="properties">determine GraphType</param>
            <returns>List with newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Add(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.Drawing.GraphType)">
            <summary>
            Add new graph(s) of arbitrary type, provide both axis data
            </summary>
            <param name="xData">x coordinates </param>
            <param name="graphType">type of graph to be added</param>
            <param name="yData">y coordinates</param>
            <returns>List with newly created graph(s)</returns>
            <remarks>The return value will be a list of all graphs created (and added),
            since more than one graph may have been specified. This depends on the 
            shape of the data provided.
            <para>Currently only Plot2D graphs are supported as GraphType! </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the data provided are nor 
            numeric or the size for one of the arrays <typeparamref name="xData"/> or <typeparamref name="yData"/> 
            do not match. </exception>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Remove(ILNumerics.Drawing.Graphs.ILGraph)">
            <summary>
            Remove a graph from the collection and rescale data limits
            </summary>
            <param name="key">key of graph to be removed</param>
            <returns>the ILGraph removed or null, if the key does not exist</returns>
            <remarks>If the graph has been removed, the clipping data will be updated and a change event will be fired. </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILGraphCollection.Limits">
            <summary>
            Clippping volume for data in all graphs of the collection
            </summary>
            <remarks>This gives back the real ILClippingData object (no copy)</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitBox3D">
            <summary>
            plot, displaying a simple colored lit 3D box
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            create new lit 3D box
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="min">minimum coordinates defining the box' dimensions (x,y,z)</param>
            <param name="max">minimum coordinates defining the box' dimensions (x,y,z)</param>
            <param name="fillColor">overall color for the box</param>
            <param name="topColor">color used to color the top edges of the box</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internally used) draws the plot 
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.m_lineProperties_Changed(System.Object,System.EventArgs)">
            <summary>
            update all quad borders with new settings
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.updateColors">
            <summary>
            distribute changed color settings to all quads 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.SetColorGradient(ILNumerics.Drawing.Shapes.ILLitQuad,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            color settings helper
            </summary>
            <param name="quad">quad index</param>
            <param name="col0">color 1</param>
            <param name="col1">color 2</param>
            <param name="col2">color 3</param>
            <param name="col3">color 4</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Opacity">
            <summary>
            get the opacity for the box or set it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.GradientColor">
            <summary>
            the color used at one corner for each quad to generate a simple gradient effect 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Edges">
            <summary>
            properties of the edge lines 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.FillColor">
            <summary>
            overall fill color (bottom and lower area of color gradient) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.TopColor">
            <summary>
            top color (top and upper area of color gradient)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.ValueLabel">
            <summary>
            reference to the label which renders the current z-value onto the top area (world coords)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.TopLabel">
            <summary>
            label drawn in screen coords on top of the lit box
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Quads">
            <summary>
            get reference to the quads, the lit box is assembled out of
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitBox3D.QuadIndices">
            <summary>
            enum for all 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILWorldLabel">
            <summary>
            general label, drawn in world coords
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILWorldLabel.#ctor(ILNumerics.Drawing.Controls.ILPanel)">
            <summary>
            create a label for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILWorldLabel.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.PositionMin">
            <summary>
            get/ set the minimum position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.PositionMax">
            <summary>
            get/ set the maximium position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.Alignment">
            <summary>
            Alignment along the axis value range. Possible values: lower, center, upper
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.Padding">
            <summary>
            Get/ set the padding used to seperate the label from the elements around it
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphRoot">
            <summary>
            the root node of every scene graph (internal use only) 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILPanel">
            <summary>
            Basic abstract base class for GL dependent display.
            </summary>
            <remarks>This control is the main plot control of ILNumerics.Net.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Controls.ILPanel.m_plotBoxScreenRectF">
            <summary>
            pixel size of the current PlotCubeScreenRectangle
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Dispose">
            <summary>
            Dispose this panel, frees all devices, graph- and axis collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Dispose(System.Boolean)">
            <summary>
            dispose this panel
            </summary>
            <param name="disposing">manual disposing</param>
            <remarks>derived classed (ILDXPanel,ILOGLPanel) free their resources here</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Refresh">
            <summary>
            causes the panel to redraw
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.GetDeviceContext">
            <summary>
            Get current rendering device (implementation dependent)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Invalidate">
            <summary>
            Causes a reconfiguration of all axes and graphs on the next paint event
            </summary>
            <remarks>Call this method after any changes to vertex relevant data. It causes all drawable objects to clear their caches and recalculate all vertex data.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.ResetView">
            <summary>
            update viewing limits to show all data, rotate the scene to default (-> DefaultView)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.ResetView(System.Boolean)">
            <summary>
            update viewing limits to show all data, optionally reset the scene rotation
            </summary>
            <param name="resetRotation">true: rotate the scene to the default (-> DefaultView)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            Move &amp; shrink/expand current view cube along a given line
            </summary>
            <param name="nearLineEnd"></param>
            <param name="farLineEnd"></param>
            <param name="offset"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            move the center of the viewing cube and expand / shrink the volume by offset
            </summary>
            <param name="center">new center</param>
            <param name="offset">offset multiplicator, 1f means: no change</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Zoome the scene to new limits
            </summary>
            <param name="luCorner">'upper left' (first) corner of the new viewing cube</param>
            <param name="rbCorner">'bottom right' (opposed) corner of the viewing cube</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Transform two coordinates for a line from world to screen coordinates
            </summary>
            <param name="start">1st coordinate (world)</param>
            <param name="end">2nd coordinate (world)</param>
            <param name="start2D">[output] 1st coordinate (screen pixels)</param>
            <param name="end2D">[output] 2nd coordinate (screen pixels)</param>
            <remarks>This function is provided by the concrete derived class, using the
            current rendering framework.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Screen2World2D(System.Int32,System.Int32)">
            <summary>
            Transform from a point on screen into world coordinates [depricated]
            </summary>
            <param name="x">screen x</param>
            <param name="y">screen y: GL viewport coord! -> (0,0) is lower left corner!</param>
            <returns>world coordinate point</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Screen2World(System.Int32,System.Int32,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            gives the line in world coords, a specific point on screen lays on
            </summary>
            <param name="x">screen x</param>
            <param name="y">screen y: GL viewport coord! -> (0,0) is lower left corner</param>
            <param name="farClip">far end point of the resulting line in world coords</param>
            <param name="nearClip">near end point of the resulting line in world coords</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Transform world coordinate to screen coordinate under current transformation
            </summary>
            <param name="worldPoint">world coordinate</param>
            <returns>screen location</returns>
            <remarks>the actual transform is carried out in the derived specialized class,
            where the current transformation matrices are known</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,System.Double[])">
            <summary>
            Transform world coordinate to screen coordinate, provide (custom) modelview matrix
            </summary>
            <param name="worldPoint"></param>
            <param name="modelview">(custom) model view matrix. The parameter must match the format required by the deriving concrete ILPanel class. ILOGLPanel: double[16]</param>
            <returns>screen location</returns>
            <remarks>the actual transform is carried out in the derived specialized class,
            where the current transformation matrices are known</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Draws content of this subfigure into predefined bitmap
            </summary>
            <param name="bitmap">predefined bitmap to draw content into. The size must have been initialized according to 'bounds'.</param>
            <param name="bounds">Rectangle specifying the region to be copied.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.drawSelectionRect(System.Drawing.Point)">
            <summary>
            draws the selection rectangle with GDI functions
            </summary>
            <param name="endPoint">end point</param>
            <remarks>The start point is stored in the member m_mouseStart.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Configure">
            <summary>
            [internal] Configure this panel, to make it ready for output, set "m_ready = true" at end!
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.iRenderingState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw the scene: all axes, graphs, background etc. (device dependant)
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Initialize">
            <summary>
            initialize all device specific classes, first called after the panel has been created
            </summary>
            <remarks>derived types should init all devices here</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.GetTransformedSize(System.Single@,System.Single@,System.Single@)">
            <summary>
            Get size of projected view cube - after (!) rotation but before projection -> world space
            includes the bounding box, tightly enclosing the current view limits setting 
            No labels, No ticks included!! Just the data cube with roatation!
            </summary>
            <param name="x">out, screen size for X</param>
            <param name="y">out, screen size for Y</param>
            <param name="z">out, screen size for Z</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.updatePlotCubeScreenRect(System.Single,System.Single,System.Drawing.Size)">
            <summary>
            calculate the real pixels of the plot cube rectangle for drawing into
            </summary>
            <param name="xSize"></param>
            <param name="ySize"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Create">
            <summary>
            create OpenGL panel 
            </summary>
            <returns>OpenGL panel</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.Create(ILNumerics.Drawing.GraphicDeviceType)">
            <summary>
            create graphic device specific panel 
            </summary>
            <param name="type">specify GL type. Supported are: OpenGL (recommended) or Direct3D (alpha state)</param>
            <returns>GL specific panel</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPanel.GetCreationFactory">
            <summary>
            Create GL dependend graph factory 
            </summary>
            <returns>ILGraphFactory,will be used for creating all graphs</returns>
            <remarks>derived types may return GL dependend factory</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.AspectRatio">
            <summary>
            Determines how the projected data plots are mapped to PlotCubeScreenRectF
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.PlotBoxScreenRect">
            <summary>
            the normalizes projected size (range 0..1) of plot cube on 2D client area, set: sets PlotCubeScreenMode -> Manual
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.PlotBoxScreenSizeMode">
            <summary>
            options for determining the size of the plot cube on the 2D screen client area, default: optimal
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Lights">
            <summary>
            Access collection of lights for configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Legend">
            <summary>
            Legend for panel's graphs
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.TextureManager">
            <summary>
            Get texture manager instance, storing all textures used in the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Colormap">
            <summary>
            Colormap used to translate color indices into true colors
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.BackgroundFilled">
            <summary>
            Determines if background of the rendering cube will be filled with the CubeBackgroundColor property value
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.DrawInactive">
            <summary>
            true: the control will always be drawn, even if it does not own the focus
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.BackColorCube">
            <summary>
            Get/set the background color for the inner cube drawing 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Limits">
            <summary>
            View settings, get access to the clipping limits for all axises 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.GraphicDeviceType">
            <summary>
            Get the type of device currently used for rendering
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.SelectionRectangle">
            <summary>
            Get/set properties for selection rectangle, drawn when zooming with the mouse
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.BackColor">
            <summary>
            color of the figure background
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Projection">
            <summary>
            type of projection: orthographic (default) or perspective
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Camera">
            <summary>
            Get or set viewport properties (distance &amp; angles)
            </summary>
            <remarks>Changing </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.InteractiveMode">
            <summary>
            Get the current mode for mouse interaction or set's it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Graphs">
            <summary>
            Gives all graphs as value collection (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.Axes">
            <summary>
            Get axes collection - holds all 3 axes
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.ClipViewData">
            <summary>
            (experimental) content for graphs will be clipped outside the unit cube
            </summary>
            <remarks>For 2D plots, not clipping the vertex data may lead to hiding 
            the labels drawn next to axes. For 3D plots Clipping may cause unexpected behavior. 
            <para>Therefore Clipping will be activated for 2D plots by default and 
            deactivated for 3D plots by default.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.TextRendererManager">
            <summary>
            Manager providing collection of available IILTextRenderer types
            </summary>
            <remarks>IILTextRenderer are used to draw labels for axis of this panel (device specific).
            <para>Text renderer objects must be instantiated through the ILTextRendererManager instance's
            CreateInstance() method.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.DefaultView">
            <summary>
            Get or set default camera position for reset of the scene
            </summary>
            <remarks>The default position is used when the scene is reset. That
            reset is usually triggered by double clicking the panel with the mouse.
            <para>setting this value to null will make the panel ignore any double
            clicks, which enables the user to manually react to double click via the 
            common DoubleClick event of the panel and reset the camera position from
            outside the component.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.AutoZoomContent">
            <summary>
            Options for the view cube adapting data limit changes 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.ZoomMode">
            <summary>
            choose the ramp for zooming
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPanel.ZoomOffset">
            <summary>
            How much the view cube will be shrinked/expanded on zooming operations (percent)
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Controls.ILPanel.DataLimitsChanged">
            <summary>
            fired, if the data limits of any graphs changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Controls.ILPanel.ViewLimitsChanged">
            <summary>
            fired, if the clipping rectangle for viewing graphs changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Controls.ILPanel.ColormapChanged">
            <summary>
            fires, if the current colormap has changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Controls.ILPanel.GraphicsDeviceReset">
            <summary>
            fired, if the internal graphics device reset (Direct3D devices only)
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Controls.ILPanel.GraphicsDeviceCreated">
            <summary>
            fired, if the internal graphics device has been (re)created
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILLineProperties">
            <summary>
            properties for line graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLineProperties.#ctor">
            <summary>
            create default properties for graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLineProperties.#ctor(ILNumerics.Drawing.ILLineProperties)">
            <summary>
            create a new instance of this class based on another instance
            </summary>
            <param name="props">properties to be copied</param>
        </member>
        <member name="E:ILNumerics.Drawing.ILLineProperties.Changed">
            <summary>
            fires if the properties were changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Width">
            <summary>
            line width (default: 1)
            </summary>
            <remarks>if antialiasing is active, it will be disabled 
            as long as the width is less than 2 and automatically 
            reenabled if the width gets larger than 1 again.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Style">
            <summary>
            line style (default: solid)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Pattern">
            <summary>
            user defined line stipple pattern for line style 'UserPattern'
            </summary>
            <remarks>the pattern is defined by corresponding bits 
            set in the short value. It may be stretched via the 
            LinePatternScale parameter. Default: 15</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.PatternScale">
            <summary>
            scaling for line stipple patterns (default: 4.0f)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Color">
            <summary>
            Line color (default: DarkOliveGreen)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Visible">
            <summary>
            get / set if lines are visible (default: true)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Antialiasing">
            <summary>
            draw lines with smooth antialiasing (if possible and supported)
            </summary>
            <remarks>If the object supports antialiased lines, edges will be drawn 
            smoothly. This sometimes comes with the drawback of the lines beeing 
            more thick. Not all objects support antialiasing. Default value is 'false'.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILTickCollection">
            <summary>
            List of labeled ticks for an axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.OnChange">
            <summary>
            fires the change event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.OnLabeledTickAdding(System.Single@,System.String@,System.Int32)">
            <summary>
            fires LabeledTickAdding event
            </summary>
            <param name="value">existing value</param>
            <param name="label">existing label</param>
            <param name="index">index of new tick in collection</param>
            <returns>true: a registrar requested to cancel the adding, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.#ctor(ILNumerics.Drawing.Controls.ILPanel,ILNumerics.Drawing.AxisNames)">
            <summary>
            creates new ILTickCollection
            </summary>
            <param name="axisName"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Clear">
            <summary>
            Clear the collection of labeled ticks
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Replace(System.Collections.Generic.List{System.Single})">
            <summary>
            replace current collection of labeled ticks with a new one
            </summary>
            <param name="ticks"></param>
            <remarks>This will fire a Change event.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Add(System.Single,System.String)">
            <summary>
            Add a labeled tick to the ticks collection.
            </summary>
            <param name="value">current position</param>
            <param name="label">current value</param>
            <remarks>This function will fire the LabeledTickAdding event. This 
            gives users the chance to modify the tick and/or the label before 
            it gets added. She can also cancel the adding for the tick at all. <br/>
            No Change event for the axis will be fired from this method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Add(System.Single)">
            <summary>
            Add a labeled tick to the ticks collection
            </summary>
            <param name="value">position for tick</param>
            <remarks>No Change event will be fired</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.CreateAuto(System.Single,System.Single,System.Int32)">
            <summary>
            fill (replace) labels with nice labels for range  
            </summary>
            <param name="min">lower limit</param>
            <param name="max">upper limit</param>
            <param name="tickCount">maximum number of ticks</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabels(System.Single,System.Single,System.Int32,ILNumerics.Drawing.TickLabelRenderingHint)">
            <summary>
            Determine nice looking label positions for range specified
            </summary>
            <param name="min">lower limit</param>
            <param name="max">upper limit</param>
            <param name="numMaxLabels">maximum number of labels </param>
            <param name="format">format string used to convert numbers to strings</param>
            <param name="hint">rendering hint, specifies preferred method</param>
            <returns>list of tick labels</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabelsAuto(System.Single,System.Single,System.Int32,System.String)">
            <summary>
            Create nice labels, prefere even numbers over best optimal tick count
            </summary>
            <param name="min">min</param>
            <param name="max">max</param>
            <param name="numMaxLabels">max labels count</param>
            <param name="format">format string used to convert numbers to strings</param>
            <returns>nice label list</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabelsFill(System.Single,System.Single,System.Int32)">
            <summary>
            find tick labels by distinct divisors (10,5,2). Chooses the divisor which best produces the best number according to numberTicks
            </summary>
            <param name="min">minimum</param>
            <param name="max">maximum</param>
            <param name="numberTicks">maximum number of ticks</param>
            <param name="format">format string for string conversion</param>
            <returns>list of tick labels</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.niceNumber(System.Double,System.Boolean)">
            <summary>
            create "nice" number in fractions of 2 or 5
            </summary>
            <param name="value">value</param>
            <returns>This code was adopted from Paul Heckbert
            from "Graphics Gems", Academic Press, 1990. </returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.GetEnumerator">
            <summary>
            Get Enumerator, enumerating over all labeled ticks
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator enumerating over labeled ticks
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Collections.ILTickCollection.Changed">
            <summary>
            Fires, when the collection of ticks has changed 
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Collections.ILTickCollection.LabeledTickAdding">
            <summary>
            fires, if a new labeled tick is about to be added to the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.TicksAllowOverlap">
            <summary>
            determine the max number of pixels allowing a tic labels to be rendered inside the padding area of the next label 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.RenderingHint">
            <summary>
            Get the prefered placement for tick labels or sets it
            </summary>
            <remarks>Tick labels will not stricly rely on this setting, but rather 
            try to find the optimal tick positions depending on the current 
            rendering situation, taking the hint into account.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Mode">
            <summary>
            Positioning mode for ticks ([Auto],Manual)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.NearColor">
            <summary>
            get / set the color for near ticks (label side)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.FarColor">
            <summary>
            get / set the color for backside ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.LabelColor">
            <summary>
             Get/ set the default color for tick labels 
            </summary>
            <remarks>The color may be overwritten for individual labels</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Padding">
            <summary>
            padding between ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Precision">
            <summary>
            number of digits to be displayed in axis ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Display">
            <summary>
            Get/ set which sides ticks for axis will be displayed on
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Direction">
            <summary>
            How ticks are displayed (inside/outside)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.TickFraction">
            <summary>
            length for ticks, fraction of the overall axis length. Default: 0.02
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Count">
            <summary>
            Number of ticks currently stored into the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Axis">
            <summary>
            The axis this tick collection is assigned to
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Size">
            <summary>
            Get maximum size of 
            all tick labels in pixels on screen
            </summary>
            <remarks>This property does not take the orientation into account. The size 
            of the content will be returned as if the orientation was straight horizontally.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.ILFigure">
            <summary>
            Stand alone figure form - capable of displaying subfigure(s)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILFigure.#ctor">
            <summary>
            create new ILFigure form
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILFigure.#ctor(ILNumerics.Drawing.Plots.ILPlot)">
            <summary>
            create a new figure and initialize it with a given plot
            </summary>
            <param name="plot">the plot to be shown in the figure</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILFigure.Tile(System.Int32,System.Int32,System.Int32)">
            <summary>
            Tile this figure into rows and columns to display multiple subfigures 
            </summary>
            <param name="rows">rows</param>
            <param name="columns">columns</param>
            <param name="current">newly active subfigure (sequential index)</param>
            <returns>newly selected active subfigure</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILFigure.ActiveSubfigure">
            <summary>
            get current active subfigure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILFigure.Subfigures">
            <summary>
            Get collection of subfigures
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILFigure.Panel">
            <summary>
            get reference to panel of current active subfigure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILFigure.Item(System.Int32,System.Int32)">
            <summary>
            Get subfigure by row and column and select as current subfigure
            </summary>
            <param name="row">location: row</param>
            <param name="col">location: column</param>
            <returns>subfigure on location specified. If row and/or column lay outside of bounds, 
            an exception will be thrown.</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILFigure.Item(System.Int32)">
            <summary>
            query subfigure by index (sequential)
            </summary>
            <param name="key">key to identify subfigure</param>
            <returns>subfigure identified by key</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel">
            <summary>
            OpenGL implementation for ILPanel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.GetDeviceContext">
            <summary>
            Gets an interface to the underlying GraphicsContext used by this GLControl.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.OnHandleCreated(System.EventArgs)">
            <summary>
            will get called after the handle has been created
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.OnHandleDestroyed(System.EventArgs)">
            <summary>
            gets called, after the handle has been destroyed
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.Dispose(System.Boolean)">
            <summary>
            Dispose off the panels resources
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.UpdateMatrices(System.Single,System.Single,System.Single)">
            <summary>
            set up viewport, projection and modelview matrices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.iRenderingState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Render the OpenGL scene
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.iRenderingState3(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            swap buffers and finalize rendering
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.drawSelectionRect(System.Drawing.Point)">
            <summary>
            draws the selection rectangle va OpenGL (rather than GDI in base class)
            </summary>
            <param name="endPoint"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.SwapBuffers">
            <summary>
            Swaps the front and back buffers, presenting the rendered scene to the screen.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.MakeCurrent">
            <summary>
            Makes the underlying this GLControl current in the calling thread.
            All OpenGL commands issued are hereafter interpreted by this GLControl.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateGraph(ILNumerics.ILBaseArray,ILNumerics.Drawing.GraphType,System.Object[])">
            <summary>
            Create specific graph (device dependent)
            </summary>
            <param name="data">numeric data to be visualized, any numeric type is accepted</param>
            <param name="type">type of graph to be created</param>
            <param name="additionalParams">user defined parameter, depend on concrete device type</param>
            <returns>Concrete ILGraph object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateAxis(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,System.Object[])">
            <summary>
            Create Axis (device dependent)
            </summary>
            <param name="name">specfies axis name (X,Y,ZAxis)</param>
            <param name="clippingView">the global clipping view object for the axis</param>
            <param name="parameters">user defined parameters (implementation dependent)</param>
            <returns>ILAXis object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateSceneGraph">
            <summary>
            create a new device dependent scene graph for hosting ILShapes, internally used
            </summary>
            <returns>scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Transform 2 world coordinates into screen coords under current matrices
            </summary>
            <param name="p1_3D">world coord point 1</param>
            <param name="p2_3D">world coord point 2</param>
            <param name="p1_2D">(output) screen coord point 1</param>
            <param name="p2_2D">(output) screen coord point 2</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.Screen2World(System.Int32,System.Int32,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            transform from screen space into world space using OpenGL
            </summary>
            <param name="x">screen X</param>
            <param name="y">screen Y</param>
            <returns>world coord</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.PolyOffsetEnable">
            <summary>
            Control polygon offset ([on]/off)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILAxisCollection">
            <summary>
            Collection of all 3 axes contained in each subfigure
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILAxisCollection.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.Interfaces.IILCreationFactory)">
            <summary>
            create new ILAxisCollection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Item(System.Int32)">
            <summary>
            Get / set ILAxis by index
            </summary>
            <param name="index">index of axis: XAxis = 0, YAxis = 1, ZAxis = 2</param>
            <returns>ILAxis specified by index</returns>
            <value>new ILAxis to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Item(ILNumerics.Drawing.AxisNames)">
            <summary>
            Get / set ILAxis by name enum
            </summary>
            <param name="name">one of the enum values: XAxis, YAxis, ZAxis</param>
            <returns>ILAxis specified by name</returns>
            <value>new ILAxis to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.XAxis">
            <summary>
            Get access to the X-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.YAxis">
            <summary>
            Get access to the Y-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.ZAxis">
            <summary>
            Get access to the Z-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.MaxTicLabelSize">
            <summary>
            Maximum size of all axes contained in the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Visible">
            <summary>
            Set visibility for all axes simultaneously
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.LinesVisible">
            <summary>
            set visibility of axis lines simultaneously
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.GridVisible">
            <summary>
            set visibility of all axis grid lines simultaneously
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor">
            <summary>
            construct new colormap, based on HLS model
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
             create specific colormap
            </summary>
            <param name="map"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor(ILNumerics.ILArray{System.Single})">
            <summary>
            create colormap based on predefined colors
            </summary>
            <param name="colors"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.Map(ILNumerics.ILArray{System.Single})">
            <summary>
            map all elements in A into final colors
            </summary>
            <param name="A">array with elements to map</param>
            <returns>colors as ILArray, the i-th row represents the color for the i-th element of A as RGB tripel.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.Map(System.Double,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            convert index value to color, interpolating
            </summary>
            <param name="value">index, position into color table, range 0...(Length-1). Values outer limits will be truncated.</param>
            <param name="r">out value: red component</param>
            <param name="g">out value: green component</param>
            <param name="b">out value: blue component</param>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Length">
            <summary>
            number of colors in the colormap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Type">
            <summary>
            The colormap type this colormap is based on (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Data">
            <summary>
            retrieve / set internal data for color indices
            </summary>
            <remarks>colors will be a matrix of exactly 3 columns. Each element will range between 0.0 ... 1.0. 
            If in set access the matrix provided contains elements outside the range, the matrix will be normalized to fit into 0.0 ... 1.0.
            <para>The array returned will be a reference of the internal data only. It cannot be used to alter internal color table! In order to alter the color table, one can query the table, alter it outside and store it back than.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.MapCreator.CreateMap(ILNumerics.Drawing.Colormaps)">
            <summary>
            create colorpam of length 128
            </summary>
            <param name="map">map specification</param>
            <returns>colormap (matrix with size [len,3])</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.MapCreator.CreateMap(ILNumerics.Drawing.Colormaps,System.Int32)">
            <summary>
            create colormap
            </summary>
            <param name="map">map specification</param>
            <param name="len">len of colormap</param>
            <returns>colormap (matrix with size [len,3])</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Marker.ILMarkerShapeProxy">
            <summary>
            Class used to enable flexible settings for marker shapes in ILMarker
            </summary>
        </member>
    </members>
</doc>
