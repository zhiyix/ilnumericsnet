//////////////////////////////////////////////////////////////////
//                                                              //
//  This is an auto - manipulated source file.                  //
//  Edits inside regions of HYCALPER AUTO GENERATED CODE        //
//  will be lost and overwritten on the next build!             //
//                                                              //
//////////////////////////////////////////////////////////////////
#region LGPL License
/*    
    This file is part of ILNumerics.Net Core Module.

    ILNumerics.Net Core Module is free software: you can redistribute it 
    and/or modify it under the terms of the GNU Lesser General Public 
    License as published by the Free Software Foundation, either version 3
    of the License, or (at your option) any later version.

    ILNumerics.Net Core Module is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ILNumerics.Net Core Module.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices; 
using ILNumerics.Storage;
using ILNumerics.Misc;
using ILNumerics.Native;
using ILNumerics.Exceptions;
/*!HC:TYPELIST:
<hycalper>
<type>
    <source locate="after">
        inArr1
    </source>
    <destination>byte</destination>
    <destination>char</destination>
    <destination>complex</destination>
    <destination>fcomplex</destination>
    <destination>float</destination>
    <destination>Int16</destination>
    <destination>Int32</destination>
    <destination>Int64</destination>
    <destination>UInt16</destination>
    <destination>UInt32</destination>
    <destination>UInt64</destination>
</type>
<type>
    <source locate="after">
        inCls1
    </source>
    <destination><![CDATA[ILArray<byte>]]></destination>
    <destination><![CDATA[ILArray<char>]]></destination>
    <destination><![CDATA[ILArray<complex>]]></destination>
    <destination><![CDATA[ILArray<fcomplex>]]></destination>
    <destination><![CDATA[ILArray<float>]]></destination>
    <destination><![CDATA[ILArray<Int16>]]></destination>
    <destination><![CDATA[ILArray<Int32>]]></destination>
    <destination><![CDATA[ILArray<Int64>]]></destination>
    <destination><![CDATA[ILArray<UInt16>]]></destination>
    <destination><![CDATA[ILArray<UInt32>]]></destination>
    <destination><![CDATA[ILArray<UInt64>]]></destination>
</type>
<type>
    <source locate="after">
        inCls2
    </source>
    <destination><![CDATA[ILArray<byte>]]></destination>
    <destination><![CDATA[ILArray<char>]]></destination>
    <destination><![CDATA[ILArray<complex>]]></destination>
    <destination><![CDATA[ILArray<fcomplex>]]></destination>
    <destination><![CDATA[ILArray<float>]]></destination>
    <destination><![CDATA[ILArray<Int16>]]></destination>
    <destination><![CDATA[ILArray<Int32>]]></destination>
    <destination><![CDATA[ILArray<Int64>]]></destination>
    <destination><![CDATA[ILArray<UInt16>]]></destination>
    <destination><![CDATA[ILArray<UInt32>]]></destination>
    <destination><![CDATA[ILArray<UInt64>]]></destination>
</type>
<type>
    <source locate="after">
        inArr2
    </source>
    <destination>byte</destination>
    <destination>char</destination>
    <destination>complex</destination>
    <destination>fcomplex</destination>
    <destination>float</destination>
    <destination>Int16</destination>
    <destination>Int32</destination>
    <destination>Int64</destination>
    <destination>UInt16</destination>
    <destination>UInt32</destination>
    <destination>UInt64</destination>
</type>
<type>
    <source locate="after">
        ClsName 
    </source>
    <destination>oplogical_bytebyte</destination>
    <destination>oplogical_charchar</destination>
    <destination>oplogical_complexcomplex</destination>
    <destination>oplogical_fcomplexfcomplex</destination>
    <destination>oplogical_floatfloat</destination>
    <destination>oplogical_int16int16</destination>
    <destination>oplogical_int32int32</destination>
    <destination>oplogical_int64int64</destination>
    <destination>oplogical_uint16uint16</destination>
    <destination>oplogical_uint32uint32</destination>
    <destination>oplogical_uint64uint64</destination>
</type>
<type>
    <source locate="after">
        TclsRelopUnary 
    </source>
    <destination>oplogical__byte</destination>
    <destination>oplogical__char</destination>
    <destination>oplogical__complex</destination>
    <destination>oplogical__fcomplex</destination>
    <destination>oplogical__float</destination>
    <destination>oplogical__int16</destination>
    <destination>oplogical__int32</destination>
    <destination>oplogical__int64</destination>
    <destination>oplogical__uint16</destination>
    <destination>oplogical__uint32</destination>
    <destination>oplogical__uint64</destination>
</type>
<type>
    <source locate="after">
        delegate_logicalbinary
    </source>
    <destination>ILLogicalFunctionByteByte</destination>
    <destination>ILLogicalFunctionCharChar</destination>
    <destination>ILLogicalFunctionComplexComplex</destination>
    <destination>ILLogicalFunctionFcomplexFcomplex</destination>
    <destination>ILLogicalFunctionFloatFloat</destination>
    <destination>ILLogicalFunctionInt16Int16</destination>
    <destination>ILLogicalFunctionInt32Int32</destination>
    <destination>ILLogicalFunctionInt64Int64</destination>
    <destination>ILLogicalFunctionUInt16UInt16</destination>
    <destination>ILLogicalFunctionUInt32UInt32</destination>
    <destination>ILLogicalFunctionUInt64UInt64</destination>
</type>
<type>
    <source locate="after">
        delegate_logicalunary
    </source>
    <destination>ILLogicalFunctionByte</destination>
    <destination>ILLogicalFunctionChar</destination>
    <destination>ILLogicalFunctionComplex</destination>
    <destination>ILLogicalFunctionFcomplex</destination>
    <destination>ILLogicalFunctionFloat</destination>
    <destination>ILLogicalFunctionInt16</destination>
    <destination>ILLogicalFunctionInt32</destination>
    <destination>ILLogicalFunctionInt64</destination>
    <destination>ILLogicalFunctionUInt16</destination>
    <destination>ILLogicalFunctionUInt32</destination>
    <destination>ILLogicalFunctionUInt64</destination>
</type>
<type>
    <source locate="after">
        logicalbinaryop
    </source>
    <destination>LogicalBinaryByteOperator</destination>
    <destination>LogicalBinaryCharOperator</destination>
    <destination>LogicalBinaryComplexOperator</destination>
    <destination>LogicalBinaryFcomplexOperator</destination>
    <destination>LogicalBinaryFloatOperator</destination>
    <destination>LogicalBinaryInt16Operator</destination>
    <destination>LogicalBinaryInt32Operator</destination>
    <destination>LogicalBinaryInt64Operator</destination>
    <destination>LogicalBinaryUInt16Operator</destination>
    <destination>LogicalBinaryUInt32Operator</destination>
    <destination>LogicalBinaryUInt64Operator</destination>
</type>
<type>
    <source locate="after">
        logicalunaryop
    </source>
    <destination>LogicalUnaryByteOperator</destination>
    <destination>LogicalUnaryCharOperator</destination>
    <destination>LogicalUnaryComplexOperator</destination>
    <destination>LogicalUnaryFcomplexOperator</destination>
    <destination>LogicalUnaryFloatOperator</destination>
    <destination>LogicalUnaryInt16Operator</destination>
    <destination>LogicalUnaryInt32Operator</destination>
    <destination>LogicalUnaryInt64Operator</destination>
    <destination>LogicalUnaryUInt16Operator</destination>
    <destination>LogicalUnaryUInt32Operator</destination>
    <destination>LogicalUnaryUInt64Operator</destination>
</type>
</hycalper>
 */

namespace ILNumerics.BuiltInFunctions {

	public partial class ILMath {

        #region HYCALPER LOOPSTART INNER_FUNCTION_DELEGATES
        private delegate byte /*!HC:delegate_logicalunary*/ ILLogicalFunctionDouble (/*!HC:inArr1*/ double in1);
        private delegate byte /*!HC:delegate_logicalbinary*/ ILLogicalFunctionDoubleDouble (/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2);
        #endregion HYCALPER LOOPEND INNER_FUNCTION_DELEGATES
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        private delegate byte  ILLogicalFunctionUInt64 ( UInt64 in1);
        private delegate byte  ILLogicalFunctionUInt64UInt64 ( UInt64 in1, UInt64 in2);
        private delegate byte  ILLogicalFunctionUInt32 ( UInt32 in1);
        private delegate byte  ILLogicalFunctionUInt32UInt32 ( UInt32 in1, UInt32 in2);
        private delegate byte  ILLogicalFunctionUInt16 ( UInt16 in1);
        private delegate byte  ILLogicalFunctionUInt16UInt16 ( UInt16 in1, UInt16 in2);
        private delegate byte  ILLogicalFunctionInt64 ( Int64 in1);
        private delegate byte  ILLogicalFunctionInt64Int64 ( Int64 in1, Int64 in2);
        private delegate byte  ILLogicalFunctionInt32 ( Int32 in1);
        private delegate byte  ILLogicalFunctionInt32Int32 ( Int32 in1, Int32 in2);
        private delegate byte  ILLogicalFunctionInt16 ( Int16 in1);
        private delegate byte  ILLogicalFunctionInt16Int16 ( Int16 in1, Int16 in2);
        private delegate byte  ILLogicalFunctionFloat ( float in1);
        private delegate byte  ILLogicalFunctionFloatFloat ( float in1, float in2);
        private delegate byte  ILLogicalFunctionFcomplex ( fcomplex in1);
        private delegate byte  ILLogicalFunctionFcomplexFcomplex ( fcomplex in1, fcomplex in2);
        private delegate byte  ILLogicalFunctionComplex ( complex in1);
        private delegate byte  ILLogicalFunctionComplexComplex ( complex in1, complex in2);
        private delegate byte  ILLogicalFunctionChar ( char in1);
        private delegate byte  ILLogicalFunctionCharChar ( char in1, char in2);
        private delegate byte  ILLogicalFunctionByte ( byte in1);
        private delegate byte  ILLogicalFunctionByteByte ( byte in1, byte in2);

#endregion HYCALPER AUTO GENERATED CODE

        // binary elementwise functions returning logical
        #region HYCALPER LOOPSTART LOGICAL_TYPE1,TYPE2
        /*!HC:TYPELIST:
<hycalper>
<type>
    <source locate="after">
        ClsName 
    </source>
    <destination>oplogical_bytebyte</destination>
    <destination>oplogical_charchar</destination>
    <destination>oplogical_complexcomplex</destination>
    <destination>oplogical_fcomplexfcomplex</destination>
    <destination>oplogical_floatfloat</destination>
    <destination>oplogical_int16int16</destination>
    <destination>oplogical_int32int32</destination>
    <destination>oplogical_int64int64</destination>
    <destination>oplogical_uint16uint16</destination>
    <destination>oplogical_uint32uint32</destination>
    <destination>oplogical_uint64uint64</destination>
</type>
<type>
    <source locate="after">
        inArr1
    </source>
    <destination>byte</destination>
    <destination>char</destination>
    <destination>complex</destination>
    <destination>fcomplex</destination>
    <destination>float</destination>
    <destination>Int16</destination>
    <destination>Int32</destination>
    <destination>Int64</destination>
    <destination>UInt16</destination>
    <destination>UInt32</destination>
    <destination>UInt64</destination>
</type>
<type>
    <source locate="after">
        inArr2
    </source>
    <destination>byte</destination>
    <destination>char</destination>
    <destination>complex</destination>
    <destination>fcomplex</destination>
    <destination>float</destination>
    <destination>Int16</destination>
    <destination>Int32</destination>
    <destination>Int64</destination>
    <destination>UInt16</destination>
    <destination>UInt32</destination>
    <destination>UInt64</destination>
</type>
<type>
    <source locate="nextline">
        EvalAND
    </source>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1.real != 0.0) && (in2.real != 0.0) && (in1.imag != 0.0) && (in2.imag != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1.real != 0.0) && (in2.real != 0.0) && (in1.imag != 0.0) && (in2.imag != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
</type>
<type>
    <source locate="nextline">
        EvalOR
    </source>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1.real != 0.0) || (in2.real != 0.0) || (in1.imag != 0.0) || (in2.imag != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1.real != 0.0) || (in2.real != 0.0) || (in1.imag != 0.0) || (in2.imag != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
    <destination><![CDATA[return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;]]></destination>
</type>
</hycalper>
*/
        private class /*!HC:ClsName*/ oplogical_doubledouble {
            internal byte eq(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and(/*!HC:inArr1*/ double in1,/*!HC:inArr2*/ double in2) {
                /*!HC:EvalAND*/
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or(/*!HC:inArr1*/ double in1, /*!HC:inArr2*/ double in2) {
                /*!HC:EvalOR*/
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
        #endregion HYCALPER LOOPEND LOGICAL_TYPE1,TYPE2
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
       
        private class  oplogical_uint64uint64 {
            internal byte eq( UInt64 in1, UInt64 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt64 in1, UInt64 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt64 in1, UInt64 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt64 in1, UInt64 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt64 in1, UInt64 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt64 in1, UInt64 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( UInt64 in1, UInt64 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( UInt64 in1,  UInt64 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_uint32uint32 {
            internal byte eq( UInt32 in1, UInt32 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt32 in1, UInt32 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt32 in1, UInt32 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt32 in1, UInt32 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt32 in1, UInt32 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt32 in1, UInt32 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( UInt32 in1, UInt32 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( UInt32 in1,  UInt32 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_uint16uint16 {
            internal byte eq( UInt16 in1, UInt16 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt16 in1, UInt16 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt16 in1, UInt16 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt16 in1, UInt16 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt16 in1, UInt16 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt16 in1, UInt16 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( UInt16 in1, UInt16 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( UInt16 in1,  UInt16 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_int64int64 {
            internal byte eq( Int64 in1, Int64 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int64 in1, Int64 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int64 in1, Int64 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int64 in1, Int64 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( Int64 in1, Int64 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int64 in1, Int64 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( Int64 in1, Int64 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( Int64 in1,  Int64 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_int32int32 {
            internal byte eq( Int32 in1, Int32 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int32 in1, Int32 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int32 in1, Int32 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int32 in1, Int32 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( Int32 in1, Int32 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int32 in1, Int32 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( Int32 in1, Int32 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( Int32 in1,  Int32 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_int16int16 {
            internal byte eq( Int16 in1, Int16 in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int16 in1, Int16 in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int16 in1, Int16 in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int16 in1, Int16 in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( Int16 in1, Int16 in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int16 in1, Int16 in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( Int16 in1, Int16 in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( Int16 in1,  Int16 in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_floatfloat {
            internal byte eq( float in1, float in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( float in1, float in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( float in1, float in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( float in1, float in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( float in1, float in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( float in1, float in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( float in1, float in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( float in1,  float in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_fcomplexfcomplex {
            internal byte eq( fcomplex in1, fcomplex in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( fcomplex in1, fcomplex in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( fcomplex in1, fcomplex in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( fcomplex in1, fcomplex in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( fcomplex in1, fcomplex in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( fcomplex in1, fcomplex in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( fcomplex in1, fcomplex in2) {
                return ((in1.real != 0.0) && (in2.real != 0.0) && (in1.imag != 0.0) && (in2.imag != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( fcomplex in1,  fcomplex in2) {
                return ((in1.real != 0.0) || (in2.real != 0.0) || (in1.imag != 0.0) || (in2.imag != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_complexcomplex {
            internal byte eq( complex in1, complex in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( complex in1, complex in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( complex in1, complex in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( complex in1, complex in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( complex in1, complex in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( complex in1, complex in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( complex in1, complex in2) {
                return ((in1.real != 0.0) && (in2.real != 0.0) && (in1.imag != 0.0) && (in2.imag != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( complex in1,  complex in2) {
                return ((in1.real != 0.0) || (in2.real != 0.0) || (in1.imag != 0.0) || (in2.imag != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_charchar {
            internal byte eq( char in1, char in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( char in1, char in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( char in1, char in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( char in1, char in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( char in1, char in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( char in1, char in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( char in1, char in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( char in1,  char in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }
       
        private class  oplogical_bytebyte {
            internal byte eq( byte in1, byte in2) {
                // TODO Pruefen auf 0.0 (oder Gleichheit) kann gefaehrlich sein wegen maximaler 
                // double Praezision.
                // Man muss besser auf ein (am besten einstellbares) eps = ca. 1e-16 prfen!
                // Siehe auch matlabs eps
                // Der logische default Wert in C# ist wohl Double.Epsilon bzw. Single.Epsilon, je nach Typ...

                // TODO: a == b <-> abs(a-b) <= eps
                // Probalby computationally too demanding? Check what matlab does!
                return (in1 == in2) ? (byte)1 : (byte)0;
            }
            internal byte neq( byte in1, byte in2) {
                // TODO: a != b <-> abs(a-b) > eps
                return (in1 != in2) ? (byte)1 : (byte)0;
            }
            internal byte lt( byte in1, byte in2) {
                // TODO: a < b <-> b-a > eps
                return (in1 < in2) ? (byte)1 : (byte)0;
            }
            internal byte gt( byte in1, byte in2) {
                // TODO: a > b <-> a-b > eps
                return (in1 > in2) ? (byte)1 : (byte)0;
            }
            internal byte le( byte in1, byte in2) {
                return (in1 <= in2) ? (byte)1 : (byte)0;
            }
            internal byte ge( byte in1, byte in2) {
                return (in1 >= in2) ? (byte)1 : (byte)0;
            }
            internal byte and( byte in1, byte in2) {
                return ((in1 != 0.0) && (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
            internal byte or( byte in1,  byte in2) {
                return ((in1 != 0.0) || (in2 != 0.0)) ? (byte)1 : (byte)0;
            }
        }

#endregion HYCALPER AUTO GENERATED CODE

        #region HYCALPER LOOPSTART LOGICAL_TYPE1
        private class /*!HC:TclsRelopUnary*/ oplogical_double {
            private /*!HC:inArr2*/ double m_parameter;
            /*!HC:delegate_logicalbinary*/ ILLogicalFunctionDoubleDouble m_applyFun;

            internal /*!HC:TclsRelopUnary*/ oplogical_double (/*!HC:inArr2*/ double parameter,
                     /*!HC:delegate_logicalbinary*/ ILLogicalFunctionDoubleDouble applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate(/*!HC:inArr1*/ double in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq(/*!HC:inArr1*/ double in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq(/*!HC:inArr1*/ double in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt(/*!HC:inArr1*/ double in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt(/*!HC:inArr1*/ double in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge(/*!HC:inArr1*/ double in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le(/*!HC:inArr1*/ double in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        #endregion HYCALPER LOOPEND LOGICAL_TYPE1
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        private class  oplogical__uint64 {
            private  UInt64 m_parameter;
            ILLogicalFunctionUInt64UInt64 m_applyFun;

            internal  oplogical__uint64 ( UInt64 parameter,
                     ILLogicalFunctionUInt64UInt64 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( UInt64 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( UInt64 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt64 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt64 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt64 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt64 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt64 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__uint32 {
            private  UInt32 m_parameter;
            ILLogicalFunctionUInt32UInt32 m_applyFun;

            internal  oplogical__uint32 ( UInt32 parameter,
                     ILLogicalFunctionUInt32UInt32 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( UInt32 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( UInt32 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt32 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt32 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt32 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt32 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt32 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__uint16 {
            private  UInt16 m_parameter;
            ILLogicalFunctionUInt16UInt16 m_applyFun;

            internal  oplogical__uint16 ( UInt16 parameter,
                     ILLogicalFunctionUInt16UInt16 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( UInt16 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( UInt16 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( UInt16 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( UInt16 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( UInt16 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( UInt16 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( UInt16 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__int64 {
            private  Int64 m_parameter;
            ILLogicalFunctionInt64Int64 m_applyFun;

            internal  oplogical__int64 ( Int64 parameter,
                     ILLogicalFunctionInt64Int64 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( Int64 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( Int64 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int64 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int64 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int64 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int64 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( Int64 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__int32 {
            private  Int32 m_parameter;
            ILLogicalFunctionInt32Int32 m_applyFun;

            internal  oplogical__int32 ( Int32 parameter,
                     ILLogicalFunctionInt32Int32 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( Int32 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( Int32 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int32 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int32 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int32 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int32 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( Int32 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__int16 {
            private  Int16 m_parameter;
            ILLogicalFunctionInt16Int16 m_applyFun;

            internal  oplogical__int16 ( Int16 parameter,
                     ILLogicalFunctionInt16Int16 applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( Int16 in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( Int16 in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( Int16 in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( Int16 in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( Int16 in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( Int16 in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( Int16 in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__float {
            private  float m_parameter;
            ILLogicalFunctionFloatFloat m_applyFun;

            internal  oplogical__float ( float parameter,
                     ILLogicalFunctionFloatFloat applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( float in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( float in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( float in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( float in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( float in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( float in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( float in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__fcomplex {
            private  fcomplex m_parameter;
            ILLogicalFunctionFcomplexFcomplex m_applyFun;

            internal  oplogical__fcomplex ( fcomplex parameter,
                     ILLogicalFunctionFcomplexFcomplex applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( fcomplex in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( fcomplex in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( fcomplex in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( fcomplex in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( fcomplex in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( fcomplex in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( fcomplex in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__complex {
            private  complex m_parameter;
            ILLogicalFunctionComplexComplex m_applyFun;

            internal  oplogical__complex ( complex parameter,
                     ILLogicalFunctionComplexComplex applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( complex in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( complex in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( complex in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( complex in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( complex in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( complex in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( complex in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__char {
            private  char m_parameter;
            ILLogicalFunctionCharChar m_applyFun;

            internal  oplogical__char ( char parameter,
                     ILLogicalFunctionCharChar applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( char in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( char in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( char in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( char in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( char in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( char in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( char in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }
        private class  oplogical__byte {
            private  byte m_parameter;
            ILLogicalFunctionByteByte m_applyFun;

            internal  oplogical__byte ( byte parameter,
                     ILLogicalFunctionByteByte applyFunc) {
                m_parameter = parameter;
                m_applyFun = applyFunc;
            }
            internal byte operate( byte in1) {
                return m_applyFun(in1, m_parameter);
            }
            internal byte eq( byte in1) {
                return (in1 == m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte neq( byte in1) {
                return (in1 != m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte gt( byte in1) {
                return (in1 > m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte lt( byte in1) {
                return (in1 < m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte ge( byte in1) {
                return (in1 >= m_parameter) ? (byte)1 : (byte)0;
            }
            internal byte le( byte in1) {
                return (in1 <= m_parameter) ? (byte)1 : (byte)0;
            }
        }

#endregion HYCALPER AUTO GENERATED CODE

        #region HYCALPER LOOPSTART OPERATORS
        private static ILLogicalArray /*!HC:logicalbinaryop*/ LogicalBinaryDoubleOperator (
            /*!HC:inCls1*/ ILArray<double> A,
            /*!HC:inCls2*/ ILArray<double> B,
            /*!HC:delegate_logicalbinary*/ ILLogicalFunctionDoubleDouble operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (/*!HC:inArr1*/ double * pInArr1 = A.m_data)
                    fixed (/*!HC:inArr2*/ double * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        /*!HC:inArr1*/ double * pIn1 = pInArr1;
                        /*!HC:inArr2*/ double * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray /*!HC:logicalunaryop*/ LogicalUnaryDoubleOperator (ILArray</*!HC:inArr1*/ double > inArray,
            /*!HC:delegate_logicalunary*/ ILLogicalFunctionDouble operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed (/*!HC:inArr1*/ double * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    /*!HC:inArr1*/ double * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed (/*!HC:inArr1*/ double * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    /*!HC:inArr1*/ double * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed (/*!HC:inArr1*/ double * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    /*!HC:inArr1*/ double * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed (/*!HC:inArr1*/ double * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            /*!HC:inArr1*/ double * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        #endregion HYCALPER LOOPEND OPERATORS
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        private static ILLogicalArray  LogicalBinaryUInt64Operator (
            ILArray<UInt64> A,
            ILArray<UInt64> B,
            ILLogicalFunctionUInt64UInt64 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( UInt64 * pInArr1 = A.m_data)
                    fixed ( UInt64 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        UInt64 * pIn1 = pInArr1;
                        UInt64 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryUInt64Operator (ILArray< UInt64 > inArray,
            ILLogicalFunctionUInt64 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt64 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt64 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    UInt64 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( UInt64 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            UInt64 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryUInt32Operator (
            ILArray<UInt32> A,
            ILArray<UInt32> B,
            ILLogicalFunctionUInt32UInt32 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( UInt32 * pInArr1 = A.m_data)
                    fixed ( UInt32 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        UInt32 * pIn1 = pInArr1;
                        UInt32 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryUInt32Operator (ILArray< UInt32 > inArray,
            ILLogicalFunctionUInt32 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt32 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt32 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    UInt32 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( UInt32 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            UInt32 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryUInt16Operator (
            ILArray<UInt16> A,
            ILArray<UInt16> B,
            ILLogicalFunctionUInt16UInt16 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( UInt16 * pInArr1 = A.m_data)
                    fixed ( UInt16 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        UInt16 * pIn1 = pInArr1;
                        UInt16 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryUInt16Operator (ILArray< UInt16 > inArray,
            ILLogicalFunctionUInt16 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt16 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    UInt16 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( UInt16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    UInt16 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( UInt16 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            UInt16 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryInt64Operator (
            ILArray<Int64> A,
            ILArray<Int64> B,
            ILLogicalFunctionInt64Int64 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( Int64 * pInArr1 = A.m_data)
                    fixed ( Int64 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        Int64 * pIn1 = pInArr1;
                        Int64 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryInt64Operator (ILArray< Int64 > inArray,
            ILLogicalFunctionInt64 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int64 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int64 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int64 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    Int64 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( Int64 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            Int64 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryInt32Operator (
            ILArray<Int32> A,
            ILArray<Int32> B,
            ILLogicalFunctionInt32Int32 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( Int32 * pInArr1 = A.m_data)
                    fixed ( Int32 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        Int32 * pIn1 = pInArr1;
                        Int32 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryInt32Operator (ILArray< Int32 > inArray,
            ILLogicalFunctionInt32 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int32 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int32 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int32 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    Int32 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( Int32 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            Int32 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryInt16Operator (
            ILArray<Int16> A,
            ILArray<Int16> B,
            ILLogicalFunctionInt16Int16 operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( Int16 * pInArr1 = A.m_data)
                    fixed ( Int16 * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        Int16 * pIn1 = pInArr1;
                        Int16 * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryInt16Operator (ILArray< Int16 > inArray,
            ILLogicalFunctionInt16 operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int16 * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    Int16 * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( Int16 * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    Int16 * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( Int16 * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            Int16 * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryFloatOperator (
            ILArray<float> A,
            ILArray<float> B,
            ILLogicalFunctionFloatFloat operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( float * pInArr1 = A.m_data)
                    fixed ( float * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        float * pIn1 = pInArr1;
                        float * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryFloatOperator (ILArray< float > inArray,
            ILLogicalFunctionFloat operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( float * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    float * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( float * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    float * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( float * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    float * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( float * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            float * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryFcomplexOperator (
            ILArray<fcomplex> A,
            ILArray<fcomplex> B,
            ILLogicalFunctionFcomplexFcomplex operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( fcomplex * pInArr1 = A.m_data)
                    fixed ( fcomplex * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        fcomplex * pIn1 = pInArr1;
                        fcomplex * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryFcomplexOperator (ILArray< fcomplex > inArray,
            ILLogicalFunctionFcomplex operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( fcomplex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    fcomplex * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( fcomplex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    fcomplex * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( fcomplex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    fcomplex * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( fcomplex * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            fcomplex * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryComplexOperator (
            ILArray<complex> A,
            ILArray<complex> B,
            ILLogicalFunctionComplexComplex operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( complex * pInArr1 = A.m_data)
                    fixed ( complex * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        complex * pIn1 = pInArr1;
                        complex * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryComplexOperator (ILArray< complex > inArray,
            ILLogicalFunctionComplex operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( complex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    complex * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( complex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    complex * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( complex * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    complex * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( complex * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            complex * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryCharOperator (
            ILArray<char> A,
            ILArray<char> B,
            ILLogicalFunctionCharChar operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( char * pInArr1 = A.m_data)
                    fixed ( char * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        char * pIn1 = pInArr1;
                        char * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryCharOperator (ILArray< char > inArray,
            ILLogicalFunctionChar operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( char * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    char * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( char * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    char * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( char * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    char * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( char * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            char * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }
        private static ILLogicalArray  LogicalBinaryByteOperator (
            ILArray<byte> A,
            ILArray<byte> B,
            ILLogicalFunctionByteByte operation) {
            ILDimension inDim = A.m_dimensions;
            if (!inDim.IsSameSize ( B.m_dimensions ))
                throw new ILDimensionMismatchException ();
            byte [] retSystemArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retSystemArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (A.IsReference || B.IsReference) {
                // this will most probably be not very fast, but .... :|
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                unsafe {
                    fixed (byte* pOutArr = retSystemArr) {
                        int c = 0; 
                        byte* poutarr = pOutArr;
                        byte* outEnd = poutarr + newLength;
                        while (poutarr < outEnd) {
                            *poutarr++ = operation ( A.GetValue(c), B.GetValue(c++) );
                        }
                    }
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed ( byte * pInArr1 = A.m_data)
                    fixed ( byte * pInArr2 = B.m_data)
                    fixed (byte* pOutArr = retSystemArr) {
                        byte* poutarr = pOutArr;
                        byte* poutend = poutarr + newLength;
                        byte * pIn1 = pInArr1;
                        byte * pIn2 = pInArr2;
                        while (poutarr < poutend)
                            *poutarr++ = operation ( *pIn1++, *pIn2++ );
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
        }
        /// <summary>
        /// Applys the function (delegate) given to all elements of the storage
        /// </summary>
        /// <param name="inArray">storage array to be apply the function to</param>
        /// <param name="operation">operation to apply to the elements of inArray. This
        /// acts like a function pointer.</param>
        /// <returns>new <![CDATA[ILArray<>]]> with result</returns>
        /// <remarks> the values of inArray will not be altered.</remarks>
        private static ILLogicalArray  LogicalUnaryByteOperator (ILArray< byte > inArray,
            ILLogicalFunctionByte operation) {
            ILDimension inDim = inArray.Dimensions;
            byte [] retByteArr;
            // build ILDimension
            int newLength = inDim.NumberOfElements;
            retByteArr = new byte [newLength];
            int leadDim = 0;
            int leadDimLen = inDim [0];
            if (inArray.IsReference) {
                #region Reference storage
                // walk along the longest dimension (for performance reasons)
                for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                    if (leadDimLen < inDim [i]) {
                        leadDimLen = inDim [i];
                        leadDim = i;
                    }
                }
                ILIndexOffset idxOffset = inArray.m_indexOffset;
                int incOut = inDim.SequentialIndexDistance ( leadDim );
                // ========================  REFERENCE double Storage ===========
                if (inArray.IsMatrix) {
                    #region Matrix
                    ////////////////////////////   MATRIX   ////////////////////
                    int secDim = ( leadDim + 1 ) % 2;
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim],
                                secDimStart = idxOffset [secDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( byte * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte * tmpIn = pInArr;
                                    byte* tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                    int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                    int* secDimIdx = secDimStart;
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + idxOffset [secDim].Length; ;
                                    while (secDimIdx < secDimEnd) {
                                        tmpIn = pInArr + *secDimIdx++;
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                } else if (inArray.IsVector) {
                    #region Vector
                    ////////////////////////////   VECTOR   ///////////////////////
                    unsafe {
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( byte * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte * tmpIn = pInArr + idxOffset [( ( leadDim + 1 ) % 2 ), 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    // start at first element
                                    while (leadDimIdx < leadDimEnd)
                                        *tmpOut++ = operation ( *( tmpIn + *leadDimIdx++ ) );
                                }
                            }
                        }
                    }
                    #endregion
                } else {
                    /////////////////////////////   ARBITRARY DIMENSIONS //////////
                    #region arbitrary size
                    unsafe {
                        int [] curPosition = new int [inArray.Dimensions.NumberOfDimensions];
                        fixed (int* leadDimStart = idxOffset [leadDim]) {
                            fixed (byte* pOutArr = retByteArr) {
                                fixed ( byte * pInArr = inArray.m_data) {
                                    byte* tmpOut = pOutArr;
                                    byte* tmpOutEnd = tmpOut + retByteArr.Length;
                                    // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                    byte * tmpIn = pInArr + inArray.getBaseIndex ( 0, 0 );
                                    tmpIn -= idxOffset [leadDim, 0];
                                    int* leadDimIdx = leadDimStart;
                                    int* leadDimEnd = leadDimStart + leadDimLen;
                                    int dimLen = curPosition.Length;
                                    int d, curD;
                                    // start at first element
                                    while (tmpOut < tmpOutEnd) {
                                        leadDimIdx = leadDimStart;
                                        while (leadDimIdx < leadDimEnd) {
                                            *tmpOut = operation ( *( tmpIn + *leadDimIdx++ ) );
                                            tmpOut += incOut;
                                        }
                                        if (tmpOut > tmpOutEnd)
                                            tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                        // increment higher dimensions 
                                        d = 1;
                                        while (d < dimLen) {
                                            curD = ( d + leadDim ) % dimLen;
                                            tmpIn -= idxOffset [curD, curPosition [curD]];
                                            curPosition [curD]++;
                                            if (curPosition [curD] < idxOffset [curD].Length) {
                                                tmpIn += idxOffset [curD, curPosition [curD]];
                                                break;
                                            }
                                            curPosition [curD] = 0;
                                            tmpIn += idxOffset [curD, 0];
                                            d++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                // ==============================================================
                #endregion
            } else {
                // physical -> pointer arithmetic
                #region physical storage
                unsafe {
                    fixed (byte* pOutArr = retByteArr) {
                        fixed ( byte * pInArr = inArray.m_data) {
                            byte* lastElement = pOutArr + retByteArr.Length;
                            byte* tmpOut = pOutArr;
                            byte * tmpIn = pInArr;
                            while (tmpOut < lastElement)
                                *tmpOut++ = operation ( *tmpIn++ );
                        }
                    }
                }
                #endregion
            }
            return new ILLogicalArray ( retByteArr, inDim.ToIntArray () );
        }

#endregion HYCALPER AUTO GENERATED CODE

 		        ////////////////////////////////  RELOP //////////////////////////////////
       #region Relational_(binary)_Operators
        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs EQ
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
        <destination>eq</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'equal' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for equal elements in A and B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND eq
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  eq ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) == B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue == *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue == *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) == *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) == *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) == *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ == *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ == *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE
        
        /// <summary>
        /// Elementwise logical 'equal' operator
        /// </summary>
        /// <param name="A">input array 1</param>
        /// <param name="B">input array 2</param>
        /// <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        /// <exception cref="ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        public static ILLogicalArray eq (ILArray<String> A, ILArray<String> B) {
            if (object.Equals(A,null)) 
                throw new ILArgumentException("eq: input argurment A must not be null!");
            if (object.Equals(B,null)) 
                throw new ILArgumentException("eq: input argurment B must not be null!");
            if (A.IsEmpty || B.IsEmpty)
                return ILLogicalArray.empty(); 
            ILLogicalArray ret = null; 
            string scalarValue; 
            ILDimension retDim = null; 
            byte[] retArr = null; 
            if (A.IsScalar) {
                if (B.IsScalar) {
                    retDim = new ILDimension(1,1); 
                    return new ILLogicalArray(new byte[1]{(A.GetValue(0) == B.GetValue(0))?(byte)1:(byte)0},1,1); 
                } else {
                    retDim = B.Dimensions.Clone(); 
                    int len = B.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    scalarValue = A.GetValue(0); 
                    for (int i = 0; i < len; i++) {
                        if (scalarValue == B.GetValue(i)) {
                            retArr[i] = 1; 
                        }
                    }
                }
            } else {
                retDim = A.Dimensions.Clone(); 
                if (B.IsScalar) {
                    int len = A.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    scalarValue = B.GetValue(0); 
                    for (int i = 0; i < len; i++) {
                        if (scalarValue == A.GetValue(i))
                            retArr[i] = 1; 
                    }
                } else {
                    if (!A.Dimensions.IsSameSize(B.Dimensions))
                        throw new ILDimensionMismatchException("eq: size of arrays must match!");
                    int len = A.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    for (int i = 0; i < len; i++) {
                        if (A.GetValue(i) == B.GetValue(i))
                            retArr[i] = 1; 
                    }
                }
            }
            return new ILLogicalArray(retArr,retDim); 
        }
        /// <summary>
        /// Elementwise logical 'not equal' operator
        /// </summary>
        /// <param name="A">input array 1</param>
        /// <param name="B">input array 2</param>
        /// <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        /// <exception cref="ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        public static ILLogicalArray neq (ILArray<String> A, ILArray<String> B) {
            if (object.Equals(A,null)) 
                throw new ILArgumentException("neq: input argurment A must not be null!");
            if (object.Equals(B,null)) 
                throw new ILArgumentException("neq: input argurment B must not be null!");
            if (A.IsEmpty || B.IsEmpty)
                return ILLogicalArray.empty(); 
            ILLogicalArray ret = null; 
            string scalarValue; 
            ILDimension retDim = null; 
            byte[] retArr = null; 
            if (A.IsScalar) {
                if (B.IsScalar) {
                    retDim = new ILDimension(1,1); 
                    ret = new ILLogicalArray(new byte[1]{(A.GetValue(0) != B.GetValue(0))?(byte)1:(byte)0},1,1); 
                } else {
                    retDim = B.Dimensions.Clone(); 
                    int len = B.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    scalarValue = A.GetValue(0); 
                    for (int i = 0; i < len; i++) {
                        if (scalarValue != B.GetValue(i)) {
                            retArr[i] = 1; 
                        }
                    }
                }
            } else {
                retDim = A.Dimensions.Clone(); 
                if (B.IsScalar) {
                    int len = A.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    scalarValue = B.GetValue(0); 
                    for (int i = 0; i < len; i++) {
                        if (scalarValue != A.GetValue(i))
                            retArr[i] = 1; 
                    }
                } else {
                    if (!A.Dimensions.IsSameSize(B.Dimensions))
                        throw new ILDimensionMismatchException("neq: size of arrays must match!");
                    int len = A.Dimensions.NumberOfElements; 
                    retArr = new byte[len]; 
                    for (int i = 0; i < len; i++) {
                        if (A.GetValue(i) != B.GetValue(i))
                            retArr[i] = 1; 
                    }
                }
            }
            return new ILLogicalArray(retArr,retDim); 
        }

        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs NEQ
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
        <destination>neq</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>                                       
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'not equal' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A not equal corresponding elements in B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND neq
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'not equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  neq ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) != B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (scalarValue != *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (scalarValue != *tmpIn++)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) != *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) != *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) != *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ != *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ != *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE

        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs LE
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
        <destination>le</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>                                       
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower or equal' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND le
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  le ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) <= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue <= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue <= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) <= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ <= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) <= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) <= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) <= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ <= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE

        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs GE
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
        <destination>ge</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>                                       
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater or equal' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND ge
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater or equal' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  ge ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) >= B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue >= *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue >= *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++)>= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) >= scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ >= scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) >= *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) >= *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) >= *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ >= *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ >= *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE
 
        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs LT
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
        <destination>lt</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>                                       
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'lower than' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND lt
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'lower than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  lt ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) < B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue < *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue < *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) < scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ < scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) < *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) < *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) < *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ <  *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ < *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE
        
        #region HYCALPER LOOPSTART BINARY_OPERATOR_TEMPLATE@Functions\builtin\Add.cs GT
/*!HC:TYPELIST:
<hycalper>
    <type>
        <source locate="after">
            inCls1
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inCls2
        </source>
        <destination><![CDATA[ILArray<double>]]></destination>
        <destination><![CDATA[ILArray<byte>]]></destination>
        <destination><![CDATA[ILArray<char>]]></destination>
        <destination><![CDATA[ILArray<complex>]]></destination>
        <destination><![CDATA[ILArray<fcomplex>]]></destination>
        <destination><![CDATA[ILArray<float>]]></destination>
        <destination><![CDATA[ILArray<Int16>]]></destination>
        <destination><![CDATA[ILArray<Int32>]]></destination>
        <destination><![CDATA[ILArray<Int64>]]></destination>
        <destination><![CDATA[ILArray<UInt16>]]></destination>
        <destination><![CDATA[ILArray<UInt32>]]></destination>
        <destination><![CDATA[ILArray<UInt64>]]></destination>
    </type>
    <type>
        <source locate="after">
            inArr1
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            inArr2
        </source>
        <destination>double</destination>
        <destination>byte</destination>
        <destination>char</destination>
        <destination>complex</destination>
        <destination>fcomplex</destination>
        <destination>float</destination>
        <destination>Int16</destination>
        <destination>Int32</destination>
        <destination>Int64</destination>
        <destination>UInt16</destination>
        <destination>UInt32</destination>
        <destination>UInt64</destination>
    </type>
    <type>
        <source locate="after">
            outCls
        </source>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
        <destination><![CDATA[ILLogicalArray]]></destination>
    </type>
    <type>
        <source locate="after">
            outArr
        </source>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
        <destination>byte</destination>
    </type>
    <type>
        <source locate="after">
            HCFuncName
        </source>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
        <destination>gt</destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute00
        </source>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
        <destination><![CDATA[return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute01
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute02
        </source>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;]]></destination>
    </type>                                       
    <type>
        <source locate="nextline">
            HCCompute03
        </source>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute04
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute05
        </source>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute06
        </source>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
        <destination><![CDATA[{ *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute07
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; ]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute08
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute09
        </source>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute10
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="nextline">
            HCCompute11
        </source>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
        <destination><![CDATA[*poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;]]></destination>
    </type>
    <type>
        <source locate="comment">
            summary
        </source>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
        <destination><![CDATA[Elementwise logical 'greater than' operator]]></destination>
    </type>
    <type>
        <source locate="comment">
            returns
        </source>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
        <destination><![CDATA[Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else]]></destination>
    </type>
 </hycalper>
 */
        #endregion HYCALPER LOOPEND gt
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<UInt64> A,  ILArray<UInt64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = A.GetValue(0); 
                    UInt64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt64 scalarValue = B.GetValue(0); 
                    UInt64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt64 tmpValue1; 
                    UInt64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt64 * inA1 = A.m_data) 
                        fixed ( UInt64 * inA2 = B.m_data) {
                            UInt64 * pInA1 = inA1; 
                            UInt64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<UInt32> A,  ILArray<UInt32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = A.GetValue(0); 
                    UInt32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt32 scalarValue = B.GetValue(0); 
                    UInt32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt32 tmpValue1; 
                    UInt32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt32 * inA1 = A.m_data) 
                        fixed ( UInt32 * inA2 = B.m_data) {
                            UInt32 * pInA1 = inA1; 
                            UInt32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<UInt16> A,  ILArray<UInt16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = A.GetValue(0); 
                    UInt16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        UInt16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    UInt16 scalarValue = B.GetValue(0); 
                    UInt16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        UInt16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( UInt16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        UInt16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( UInt16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                UInt16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    UInt16 tmpValue1; 
                    UInt16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( UInt16 * inA1 = A.m_data) 
                        fixed ( UInt16 * inA2 = B.m_data) {
                            UInt16 * pInA1 = inA1; 
                            UInt16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<Int64> A,  ILArray<Int64> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = A.GetValue(0); 
                    Int64 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int64 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int64 scalarValue = B.GetValue(0); 
                    Int64 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int64 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int64 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int64 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int64 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int64 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int64 tmpValue1; 
                    Int64 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int64 * inA1 = A.m_data) 
                        fixed ( Int64 * inA2 = B.m_data) {
                            Int64 * pInA1 = inA1; 
                            Int64 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<Int32> A,  ILArray<Int32> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = A.GetValue(0); 
                    Int32 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int32 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int32 scalarValue = B.GetValue(0); 
                    Int32 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int32 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int32 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int32 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int32 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int32 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int32 tmpValue1; 
                    Int32 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int32 * inA1 = A.m_data) 
                        fixed ( Int32 * inA2 = B.m_data) {
                            Int32 * pInA1 = inA1; 
                            Int32 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<Int16> A,  ILArray<Int16> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = A.GetValue(0); 
                    Int16 tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        Int16 * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    Int16 scalarValue = B.GetValue(0); 
                    Int16 tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        Int16 * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( Int16 * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        Int16 * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( Int16 * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                Int16 * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    Int16 tmpValue1; 
                    Int16 tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( Int16 * inA1 = A.m_data) 
                        fixed ( Int16 * inA2 = B.m_data) {
                            Int16 * pInA1 = inA1; 
                            Int16 * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<float> A,  ILArray<float> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = A.GetValue(0); 
                    float tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        float * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    float scalarValue = B.GetValue(0); 
                    float tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        float * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( float * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        float * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( float * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                float * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    float tmpValue1; 
                    float tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( float * inA1 = A.m_data) 
                        fixed ( float * inA2 = B.m_data) {
                            float * pInA1 = inA1; 
                            float * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = A.GetValue(0); 
                    fcomplex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        fcomplex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    fcomplex scalarValue = B.GetValue(0); 
                    fcomplex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        fcomplex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( fcomplex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        fcomplex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( fcomplex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                fcomplex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    fcomplex tmpValue1; 
                    fcomplex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( fcomplex * inA1 = A.m_data) 
                        fixed ( fcomplex * inA2 = B.m_data) {
                            fcomplex * pInA1 = inA1; 
                            fcomplex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<complex> A,  ILArray<complex> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = A.GetValue(0); 
                    complex tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        complex * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    complex scalarValue = B.GetValue(0); 
                    complex tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        complex * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( complex * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        complex * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( complex * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                complex * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    complex tmpValue1; 
                    complex tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( complex * inA1 = A.m_data) 
                        fixed ( complex * inA2 = B.m_data) {
                            complex * pInA1 = inA1; 
                            complex * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<char> A,  ILArray<char> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = A.GetValue(0); 
                    char tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        char * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    char scalarValue = B.GetValue(0); 
                    char tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        char * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( char * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        char * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( char * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                char * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    char tmpValue1; 
                    char tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( char * inA1 = A.m_data) 
                        fixed ( char * inA2 = B.m_data) {
                            char * pInA1 = inA1; 
                            char * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<byte> A,  ILArray<byte> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = A.GetValue(0); 
                    byte tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        byte * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    byte scalarValue = B.GetValue(0); 
                    byte tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( byte * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        byte * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( byte * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                byte * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    byte tmpValue1; 
                    byte tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( byte * inA1 = A.m_data) 
                        fixed ( byte * inA2 = B.m_data) {
                            byte * pInA1 = inA1; 
                            byte * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }
        /// <summary>Elementwise logical 'greater than' operator</summary>
        /// <param name="A">input 1</param>
        /// <param name="B">input 2</param>
        /// <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
        /// <remarks><para>On empty input - empty array will be returned.</para>
        /// <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        /// <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        public static  ILLogicalArray  gt ( ILArray<double> A,  ILArray<double> B) {
            if (A.IsEmpty || B.IsEmpty ) {
                return  ILLogicalArray .empty(); 
            }
            if (A.IsScalar) {
                if (B.IsScalar) {
                    return new ILLogicalArray (new byte[1]{(A.GetValue(0) > B.GetValue(0))? (byte)1: (byte)0});
                } else {
                    #region scalar + array  
                    ILDimension inDim = B.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = A.GetValue(0); 
                    double tmpValue2; 
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (B.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = B.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!B.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (B.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > B.GetValue(0))?(byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [B.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = B.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init lesezeiger: add alle Dimensionen mit 0 (auer leadDim)
                                        double * tmpIn = pInArr + B.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {
                                                *tmpOut = (scalarValue > *(tmpIn + *leadDimIdx++))? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = B.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) //HC03
                                    { *tmpOut++ = (scalarValue > *tmpIn++)? (byte)1:(byte)0;}
                            }       
                        }
                        #endregion
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion scalar + array
                }
            } else {
                if (B.IsScalar) {
                    #region array + scalar
                    ILDimension inDim = A.Dimensions;
                    //  byte [] retArr = new  byte [inDim.NumberOfElements];
                    byte [] retArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    double scalarValue = B.GetValue(0); 
                    double tmpValue1;
                    int leadDim = 0,leadDimLen = inDim [0];
                    if (A.IsReference) {
                        #region Reference storage
                        // walk along the longest dimension (for performance reasons)
                        ILIndexOffset idxOffset = A.m_indexOffset;
                        int incOut = inDim.SequentialIndexDistance ( leadDim );
                        System.Diagnostics.Debug.Assert(!A.IsVector,"Reference arrays of vector size should not exist!"); 
                        for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                            if (leadDimLen < inDim [i]) {
                                leadDimLen = inDim [i];
                                leadDim = i;
                                incOut = inDim.SequentialIndexDistance ( leadDim );
                            }
                        }
                        if (A.IsMatrix) {
                            #region Matrix
                            ////////////////////////////   MATRIX   ////////////////////
                            int secDim = ( leadDim + 1 ) % 2;
                            unsafe {
                                fixed (int* leadDimStart = idxOffset [leadDim],secDimStart = idxOffset [secDim])
                                fixed ( byte * pOutArr = retArr)
                                fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        double * tmpIn = pInArr;
                                        byte * tmpOutEnd = pOutArr + inDim.NumberOfElements - 1;
                                        int* secDimEnd = secDimStart + idxOffset [secDim].Length;
                                        int* secDimIdx = secDimStart;
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        while (secDimIdx < secDimEnd) {
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOut - tmpOutEnd);
                                            tmpIn = pInArr + *secDimIdx++;
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) { //HC04
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                        }
                                }
                            }
                            #endregion
                        } else {
                            #region arbitrary size
                            unsafe {
                                int [] curPosition = new int [A.Dimensions.NumberOfDimensions];
                                fixed (int* leadDimStart = idxOffset [leadDim]) {
                                    fixed ( byte * pOutArr = retArr)
                                    fixed ( double * pInArr = A.m_data) {
                                        byte * tmpOut = pOutArr;
                                        byte * tmpOutEnd = tmpOut + retArr.Length;
                                        // init readpointer: add all Dimensions with 0 (except leadDim)
                                        double * tmpIn = pInArr + A.getBaseIndex (0,0);
                                        tmpIn -= idxOffset [leadDim, 0];
                                        int* leadDimIdx = leadDimStart;
                                        int* leadDimEnd = leadDimStart + leadDimLen;
                                        int dimLen = curPosition.Length;
                                        int d, curD;
                                        // start at first element
                                        while (tmpOut < tmpOutEnd) {
                                            leadDimIdx = leadDimStart;
                                            while (leadDimIdx < leadDimEnd) {   //HC05
                                                *tmpOut = (*(tmpIn + *leadDimIdx++) > scalarValue)? (byte)1:(byte)0;
                                                tmpOut += incOut;
                                            }
                                            if (tmpOut > tmpOutEnd)
                                                tmpOut = pOutArr + ( tmpOutEnd - tmpOut );

                                            // increment higher dimensions 
                                            d = 1;
                                            while (d < dimLen) {
                                                curD = ( d + leadDim ) % dimLen;
                                                tmpIn -= idxOffset [curD, curPosition [curD]];
                                                curPosition [curD]++;
                                                if (curPosition [curD] < idxOffset [curD].Length) {
                                                    tmpIn += idxOffset [curD, curPosition [curD]];
                                                    break;
                                                }
                                                curPosition [curD] = 0;
                                                tmpIn += idxOffset [curD, 0];
                                                d++;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion
                    } else {
                        // physical -> pointer arithmetic
                        #region physical storage
                        unsafe {
                            fixed ( byte * pOutArr = retArr)
                            fixed ( double * pInArr = A.m_data) {
                                byte * lastElement = pOutArr + retArr.Length;
                                byte * tmpOut = pOutArr;
                                double * tmpIn = pInArr;
                                while (tmpOut < lastElement) { //HC06
                                    { *tmpOut++ = (*tmpIn++ > scalarValue)? (byte)1:(byte)0;}
                                }
                            }
                        }
                        #endregion
                        //tmpValue1 = 0; 
                    }
                    return new  ILLogicalArray ( retArr, inDim.Clone() );
                    #endregion array + scalar
                } else {
                    #region array + array
                    ILDimension inDim = A.Dimensions;
                    if (!inDim.IsSameSize ( B.Dimensions ))
                        throw new ILDimensionMismatchException ();
                    byte [] retSystemArr;
                    double tmpValue1; 
                    double tmpValue2; 
                    // retSystemArr = new  byte [inDim.NumberOfElements];
                    retSystemArr = ILMemoryPool.Pool.New< byte > (inDim.NumberOfElements);
                    
                    int leadDim = 0, leadDimLen = inDim [0];
                    // this will most probably be not very fast, but .... :|
                    // walk along the longest dimension (for performance reasons)
                    for (int i = 1; i < inDim.NumberOfDimensions; i++) {
                        if (leadDimLen < inDim [i]) {
                            leadDimLen = inDim [i];
                            leadDim = i;
                        }
                    }
                    unsafe {
                        fixed ( byte * pOutArr = retSystemArr)
                        fixed ( double * inA1 = A.m_data) 
                        fixed ( double * inA2 = B.m_data) {
                            double * pInA1 = inA1; 
                            double * pInA2 = inA2;
                            int c = 0; 
                            byte * poutarr = pOutArr;
                            byte * outEnd = poutarr + retSystemArr.Length;
                            if (A.IsReference) { 
                                if (!B.IsReference) {
                                    while (poutarr < outEnd) {  //HC07
                                        *poutarr++ = (*(pInA1 + A.getBaseIndex(c++)) > *pInA2++)? (byte)1:(byte)0; 
                                    }
                                } else {
                                    // optimization for matrix 
                                    if (inDim.NumberOfDimensions < 3) {
                                        fixed (int * pA1idx0 = A.m_indexOffset[0])
                                        fixed (int * pA1idx1 = A.m_indexOffset[1])
                                        fixed (int * pA2idx0 = B.m_indexOffset[0])
                                        fixed (int * pA2idx1 = B.m_indexOffset[1]) {
                                            int r = 0, rLen = A.m_dimensions[0];
                                            int        cLen = A.m_dimensions[1]; 
                                            while (poutarr < outEnd) {   //HC08
                                                *poutarr++ = (*(pInA1 + *(pA1idx0 + r) + *(pA1idx1 + c)) > *(pInA2+ *(pA2idx0 + r) + *(pA2idx1 + c)))?(byte)1:(byte)0;
                                                if (++r == rLen) {
                                                    r = 0; 
                                                    c++; 
                                                }
                                            }
                                        }
                                    } else {
                                         while (poutarr < outEnd) {  //HC09
                                             *poutarr++ = (*(pInA1 + A.getBaseIndex(c)) > *(pInA2+B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                        }
                                   }
                                   // tmpValue1 = 0; tmpValue2 = 0; 
                                }
                            } else {
                                if (B.IsReference) {
                                    while (poutarr < outEnd) {  //HC10
                                        *poutarr++ = (*pInA1++ > *(pInA2 + B.getBaseIndex(c++)))?(byte)1:(byte)0;
                                    }
                                } else {
                                    while (poutarr < outEnd) {  //HC11
                                        *poutarr++ = (*pInA1++ > *pInA2++)?(byte)1:(byte)0;
                                    }
                                }
                            }
                        }
                    }
                    return new  ILLogicalArray ( retSystemArr, inDim.ToIntArray () );
                    #endregion array + array
                }
            }
        }

#endregion HYCALPER AUTO GENERATED CODE
        
        #region HYCALPER LOOPSTART AND &  OR
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and(/*!HC:inCls1*/ ILArray<double> A, /*!HC:inCls2*/ ILArray<double> B) {
            /*!HC:ClsName*/ oplogical_doubledouble helper = new /*!HC:ClsName*/ oplogical_doubledouble ();
            return /*!HC:logicalbinaryop*/ LogicalBinaryDoubleOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or(/*!HC:inCls1*/ ILArray<double> A, /*!HC:inCls2*/ ILArray<double> B) {
            /*!HC:ClsName*/ oplogical_doubledouble helper = new /*!HC:ClsName*/ oplogical_doubledouble ();
            return /*!HC:logicalbinaryop*/ LogicalBinaryDoubleOperator (A, B, helper.or);
        }
        #endregion HYCALPER LOOPEND
#region HYCALPER AUTO GENERATED CODE
// DO NOT EDIT INSIDE THIS REGION !! CHANGES WILL BE LOST !! 
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<UInt64> A,  ILArray<UInt64> B) {
            oplogical_uint64uint64 helper = new  oplogical_uint64uint64 ();
            return  LogicalBinaryUInt64Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<UInt64> A,  ILArray<UInt64> B) {
            oplogical_uint64uint64 helper = new  oplogical_uint64uint64 ();
            return  LogicalBinaryUInt64Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<UInt32> A,  ILArray<UInt32> B) {
            oplogical_uint32uint32 helper = new  oplogical_uint32uint32 ();
            return  LogicalBinaryUInt32Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<UInt32> A,  ILArray<UInt32> B) {
            oplogical_uint32uint32 helper = new  oplogical_uint32uint32 ();
            return  LogicalBinaryUInt32Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<UInt16> A,  ILArray<UInt16> B) {
            oplogical_uint16uint16 helper = new  oplogical_uint16uint16 ();
            return  LogicalBinaryUInt16Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<UInt16> A,  ILArray<UInt16> B) {
            oplogical_uint16uint16 helper = new  oplogical_uint16uint16 ();
            return  LogicalBinaryUInt16Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<Int64> A,  ILArray<Int64> B) {
            oplogical_int64int64 helper = new  oplogical_int64int64 ();
            return  LogicalBinaryInt64Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<Int64> A,  ILArray<Int64> B) {
            oplogical_int64int64 helper = new  oplogical_int64int64 ();
            return  LogicalBinaryInt64Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<Int32> A,  ILArray<Int32> B) {
            oplogical_int32int32 helper = new  oplogical_int32int32 ();
            return  LogicalBinaryInt32Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<Int32> A,  ILArray<Int32> B) {
            oplogical_int32int32 helper = new  oplogical_int32int32 ();
            return  LogicalBinaryInt32Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<Int16> A,  ILArray<Int16> B) {
            oplogical_int16int16 helper = new  oplogical_int16int16 ();
            return  LogicalBinaryInt16Operator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<Int16> A,  ILArray<Int16> B) {
            oplogical_int16int16 helper = new  oplogical_int16int16 ();
            return  LogicalBinaryInt16Operator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<float> A,  ILArray<float> B) {
            oplogical_floatfloat helper = new  oplogical_floatfloat ();
            return  LogicalBinaryFloatOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<float> A,  ILArray<float> B) {
            oplogical_floatfloat helper = new  oplogical_floatfloat ();
            return  LogicalBinaryFloatOperator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            oplogical_fcomplexfcomplex helper = new  oplogical_fcomplexfcomplex ();
            return  LogicalBinaryFcomplexOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<fcomplex> A,  ILArray<fcomplex> B) {
            oplogical_fcomplexfcomplex helper = new  oplogical_fcomplexfcomplex ();
            return  LogicalBinaryFcomplexOperator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<complex> A,  ILArray<complex> B) {
            oplogical_complexcomplex helper = new  oplogical_complexcomplex ();
            return  LogicalBinaryComplexOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<complex> A,  ILArray<complex> B) {
            oplogical_complexcomplex helper = new  oplogical_complexcomplex ();
            return  LogicalBinaryComplexOperator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<char> A,  ILArray<char> B) {
            oplogical_charchar helper = new  oplogical_charchar ();
            return  LogicalBinaryCharOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<char> A,  ILArray<char> B) {
            oplogical_charchar helper = new  oplogical_charchar ();
            return  LogicalBinaryCharOperator (A, B, helper.or);
        }
        /// <summary>
        /// elementwise logical 'and' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray and( ILArray<byte> A,  ILArray<byte> B) {
            oplogical_bytebyte helper = new  oplogical_bytebyte ();
            return  LogicalBinaryByteOperator (A, B, helper.and);
        }
        /// <summary>
        /// elementwise logical 'or' operator 
        /// </summary>
        /// <param name="A">input array A</param>
        /// <param name="B">input array B</param>
        /// <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
        /// <remarks>A and B must have the same size or either one may be scalar.</remarks>
        public static ILLogicalArray or( ILArray<byte> A,  ILArray<byte> B) {
            oplogical_bytebyte helper = new  oplogical_bytebyte ();
            return  LogicalBinaryByteOperator (A, B, helper.or);
        }

#endregion HYCALPER AUTO GENERATED CODE
        #endregion Relational_(binary)_Operators

    }
}
